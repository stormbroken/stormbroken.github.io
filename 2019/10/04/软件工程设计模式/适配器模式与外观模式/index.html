<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="适配器模式与外观模式271页    1. 适配者模式的引入 1.1. 什么是适配器 1.2. 适配器的例子 1.3. 我们如何使用适配器 1.4. 一些关于适配器的问题   2. 适配器模式 2.1. 定义 2.2. 分类 2.2.1. 对象适配器 2.2.2. 类的适配器   2.3. 真实世界的适配器 2.3.1. 旧世界的适配器 2.3.2. 新世界的适配器 2.3.3. 问题产生及解决 2">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="适配器模式与外观模式271页    1. 适配者模式的引入 1.1. 什么是适配器 1.2. 适配器的例子 1.3. 我们如何使用适配器 1.4. 一些关于适配器的问题   2. 适配器模式 2.1. 定义 2.2. 分类 2.2.1. 对象适配器 2.2.2. 类的适配器   2.3. 真实世界的适配器 2.3.1. 旧世界的适配器 2.3.2. 新世界的适配器 2.3.3. 问题产生及解决 2">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-1.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-2.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-3.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-4.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-5.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-6.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-7.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-8.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/wg-1.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/wg-2.png">
<meta property="og:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/wg-3.png">
<meta property="og:updated_time" content="2019-09-15T05:45:37.904Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="适配器模式与外观模式271页    1. 适配者模式的引入 1.1. 什么是适配器 1.2. 适配器的例子 1.3. 我们如何使用适配器 1.4. 一些关于适配器的问题   2. 适配器模式 2.1. 定义 2.2. 分类 2.2.1. 对象适配器 2.2.2. 类的适配器   2.3. 真实世界的适配器 2.3.1. 旧世界的适配器 2.3.2. 新世界的适配器 2.3.3. 问题产生及解决 2">
<meta name="twitter:image" content="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/img/spq-1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-软件工程设计模式/适配器模式与外观模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/04/软件工程设计模式/适配器模式与外观模式/" class="article-date">
  <time datetime="2019-10-04T13:20:22.970Z" itemprop="datePublished">2019-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>适配器模式与外观模式</strong><br>271页</p>
<!-- TOC -->

<ul>
<li><a href="#1-适配者模式的引入">1. 适配者模式的引入</a><ul>
<li><a href="#11-什么是适配器">1.1. 什么是适配器</a></li>
<li><a href="#12-适配器的例子">1.2. 适配器的例子</a></li>
<li><a href="#13-我们如何使用适配器">1.3. 我们如何使用适配器</a></li>
<li><a href="#14-一些关于适配器的问题">1.4. 一些关于适配器的问题</a></li>
</ul>
</li>
<li><a href="#2-适配器模式">2. 适配器模式</a><ul>
<li><a href="#21-定义">2.1. 定义</a></li>
<li><a href="#22-分类">2.2. 分类</a><ul>
<li><a href="#221-对象适配器">2.2.1. 对象适配器</a></li>
<li><a href="#222-类的适配器">2.2.2. 类的适配器</a></li>
</ul>
</li>
<li><a href="#23-真实世界的适配器">2.3. 真实世界的适配器</a><ul>
<li><a href="#231-旧世界的适配器">2.3.1. 旧世界的适配器</a></li>
<li><a href="#232-新世界的适配器">2.3.2. 新世界的适配器</a></li>
<li><a href="#233-问题产生及解决">2.3.3. 问题产生及解决</a></li>
<li><a href="#234-设计适配器">2.3.4. 设计适配器</a></li>
</ul>
</li>
<li><a href="#24-装饰者模式和适配者模式的差异">2.4. 装饰者模式和适配者模式的差异</a></li>
</ul>
</li>
<li><a href="#3-外观模式的引入">3. 外观模式的引入</a><ul>
<li><a href="#31-例子家庭影院">3.1. 例子:家庭影院</a><ul>
<li><a href="#311-问题解决">3.1.1. 问题解决</a></li>
</ul>
</li>
<li><a href="#32-简要了解外观模式">3.2. 简要了解外观模式</a></li>
<li><a href="#33-影院问题的解决">3.3. 影院问题的解决</a></li>
</ul>
</li>
<li><a href="#4-外观模式">4. 外观模式</a></li>
<li><a href="#5-oo原则最少知识原则墨忒耳法则">5. OO原则:“最少知识”原则(墨忒耳法则)</a><ul>
<li><a href="#51-原则内容">5.1. 原则内容</a></li>
<li><a href="#52-如何做到这一点呢">5.2. 如何做到这一点呢？</a></li>
<li><a href="#53-最少知识原则弊端">5.3. 最少知识原则弊端</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="1-适配者模式的引入"><a href="#1-适配者模式的引入" class="headerlink" title="1. 适配者模式的引入"></a>1. 适配者模式的引入</h1><ol>
<li>现在是以不同的目的，包装某些对象:让他们的接口看起来不像自己而像别的东西。</li>
<li>为什么要这么做呢？因为这样就可以在类的设计中，将类的接口转换成想要的接口，以便实现不同的接口。</li>
</ol>
<h2 id="1-1-什么是适配器"><a href="#1-1-什么是适配器" class="headerlink" title="1.1. 什么是适配器"></a>1.1. 什么是适配器</h2><ol>
<li>适配器改变了插座的接口，让其更加符合相应的需求。</li>
<li>如果你不想要改变现有的代码，那么你在两个不兼容的系统之间，需要的是适配器。</li>
</ol>
<img src="img\spq-1.png">

<h2 id="1-2-适配器的例子"><a href="#1-2-适配器的例子" class="headerlink" title="1.2. 适配器的例子"></a>1.2. 适配器的例子</h2><ol>
<li>假设你缺少鸭子对象，并且想要用一些火鸡对象来冒充，那么你需要写一个适配器:</li>
</ol>
<img src="img\spq-2.png">

<h2 id="1-3-我们如何使用适配器"><a href="#1-3-我们如何使用适配器" class="headerlink" title="1.3. 我们如何使用适配器"></a>1.3. 我们如何使用适配器</h2><ol>
<li>客户使用适配器的过程如下:<ol>
<li>客户通过目标接口调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换成适配者的一个或多个调用接口。(translatedRequest)</li>
<li>客户接受到调用的结果，但并未察觉这一切是适配器在起换作用。</li>
</ol>
</li>
<li>那么我们可以看出来在上述过程中，客户和适配者是解耦的，彼此互相不知道。</li>
</ol>
<h2 id="1-4-一些关于适配器的问题"><a href="#1-4-一些关于适配器的问题" class="headerlink" title="1.4. 一些关于适配器的问题"></a>1.4. 一些关于适配器的问题</h2><ol>
<li>适配器的大小<ul>
<li>从总体上来讲适配器的大小从整体上来讲和目标接口的大小成正比。</li>
</ul>
</li>
<li>一个适配器只能够封装一个类吗？<ul>
<li>虽然大多数的适配器模式都只能包装一个被适配者。但是在一些情况下，我们需要让一个适配器的包装类来适配多个被适配者。</li>
</ul>
</li>
<li>如果我的系统中新旧并存，在接口进行更新后的适配器不能进行修改？<ul>
<li>我们可以创建一个双向的适配器，同时支持两边的接口，这样可以同时被用作新的接口和旧的接口。</li>
</ul>
</li>
</ol>
<h1 id="2-适配器模式"><a href="#2-适配器模式" class="headerlink" title="2. 适配器模式"></a>2. 适配器模式</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1. 定义"></a>2.1. 定义</h2><ol>
<li>适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原来接口不兼容的类可以合作无间。</li>
</ol>
<h2 id="2-2-分类"><a href="#2-2-分类" class="headerlink" title="2.2. 分类"></a>2.2. 分类</h2><h3 id="2-2-1-对象适配器"><a href="#2-2-1-对象适配器" class="headerlink" title="2.2.1. 对象适配器"></a>2.2.1. 对象适配器</h3><ol>
<li>类图</li>
</ol>
<img src="img\spq-3.png">

<ol start="2">
<li>特点:<ol>
<li>使用组合，可以适配某个类，包括其子类。</li>
</ol>
</li>
</ol>
<h3 id="2-2-2-类的适配器"><a href="#2-2-2-类的适配器" class="headerlink" title="2.2.2. 类的适配器"></a>2.2.2. 类的适配器</h3><ol>
<li>类图</li>
</ol>
<img src="img\spq-4.png">

<ol start="2">
<li>问题:在java中不支持多重继承，所以不支持这样子的适配器。</li>
<li>特点:<ol>
<li>因为是继承，所以其在必要的时候可以覆盖被适配者的行为。</li>
<li>效率高，无需被适配者和一个适配器。</li>
</ol>
</li>
</ol>
<h2 id="2-3-真实世界的适配器"><a href="#2-3-真实世界的适配器" class="headerlink" title="2.3. 真实世界的适配器"></a>2.3. 真实世界的适配器</h2><h3 id="2-3-1-旧世界的适配器"><a href="#2-3-1-旧世界的适配器" class="headerlink" title="2.3.1. 旧世界的适配器"></a>2.3.1. 旧世界的适配器</h3><ol>
<li>集合(collection)类型中的elements()的方法，该方法返回一个Enumeration(举)。这个集合可以逐一走过集合中的每个元素，而无需知道它们在集合内是如何被管理的。</li>
</ol>
<img src="img\spq-5.png">

<h3 id="2-3-2-新世界的适配器"><a href="#2-3-2-新世界的适配器" class="headerlink" title="2.3.2. 新世界的适配器"></a>2.3.2. 新世界的适配器</h3><ol>
<li>在Sun推出新的集合类的时候，开始使用了Iterator(迭代器)接口.</li>
</ol>
<img src="img\spq-6.png">

<h3 id="2-3-3-问题产生及解决"><a href="#2-3-3-问题产生及解决" class="headerlink" title="2.3.3. 问题产生及解决"></a>2.3.3. 问题产生及解决</h3><ol>
<li>那么问题来了，我们面对遗留代码，这些代码暴露出枚举器的接口，但我又希望在新的代码中只是用迭代器。</li>
<li>所以我们一般是使用适配器模式来解决这个问题。</li>
</ol>
<h3 id="2-3-4-设计适配器"><a href="#2-3-4-设计适配器" class="headerlink" title="2.3.4. 设计适配器"></a>2.3.4. 设计适配器</h3><img src="img\spq-7.png">

<ol>
<li>那么问题来了:没有remove()这个方法的对应怎么办呢？</li>
<li>首先类图如下</li>
</ol>
<img src="img\spq-8.png">

<ol start="3">
<li>解决这个问题:我们最终选择抛出一个运行时异常，抛出UnsupportedOperationException。<ul>
<li><code>throw new UnsupportedOperationException();</code></li>
</ul>
</li>
</ol>
<h2 id="2-4-装饰者模式和适配者模式的差异"><a href="#2-4-装饰者模式和适配者模式的差异" class="headerlink" title="2.4. 装饰者模式和适配者模式的差异"></a>2.4. 装饰者模式和适配者模式的差异</h2><ol>
<li>装饰者模式:<ul>
<li>我们可以让相应新的责任和义务加入我们。</li>
</ul>
</li>
<li>适配者模式:<ul>
<li>我们允许客户使用新的库和子集合，无需改变代码。</li>
</ul>
</li>
</ol>
<h1 id="3-外观模式的引入"><a href="#3-外观模式的引入" class="headerlink" title="3. 外观模式的引入"></a>3. 外观模式的引入</h1><ol>
<li>外观模式主要是为了简化接口，让接口更加简单。</li>
</ol>
<h2 id="3-1-例子-家庭影院"><a href="#3-1-例子-家庭影院" class="headerlink" title="3.1. 例子:家庭影院"></a>3.1. 例子:家庭影院</h2><ol>
<li>当你装好了家庭影院之后，在观赏电影之前还要做很多的前置工作。</li>
<li>在你看完电影后，你还要逐一关闭。</li>
<li>以上都是问题。</li>
</ol>
<h3 id="3-1-1-问题解决"><a href="#3-1-1-问题解决" class="headerlink" title="3.1.1. 问题解决"></a>3.1.1. 问题解决</h3><ol>
<li>你要将一个复杂的子系统变得更加容易使用，也就是简化复杂系统。</li>
</ol>
<img src="img\wg-1.png">

<img src="img\wg-2.png">

<ol start="2">
<li>那么外观模式究竟解决了什么?外观模式提供了更加直接的操作给你，只是将子系统阻隔了起来。</li>
</ol>
<h2 id="3-2-简要了解外观模式"><a href="#3-2-简要了解外观模式" class="headerlink" title="3.2. 简要了解外观模式"></a>3.2. 简要了解外观模式</h2><ol>
<li>外观没有“封装”子系统，只是提供了简化的接口。你可以直接调用里面的。</li>
<li>外观模式可以附加相应的功能，调整整个的性能。</li>
<li>对于每个子系统，可以有多个外观模式。</li>
<li>外观模式可以将客户从组建的子系统中解耦。<br> +如果你升级了你的外观，客户代码是针对外观来做的，那么你不需要修改客户代码，直接修改外观代码即可。</li>
</ol>
<h2 id="3-3-影院问题的解决"><a href="#3-3-影院问题的解决" class="headerlink" title="3.3. 影院问题的解决"></a>3.3. 影院问题的解决</h2><ol>
<li>常见一个外观，持有所有子系统，然后有相应的需要的方法可以极大精简客户端的代码数量。</li>
</ol>
<h1 id="4-外观模式"><a href="#4-外观模式" class="headerlink" title="4. 外观模式"></a>4. 外观模式</h1><ol>
<li>模式定义:外观模式提供了一个统一的接口，用来访问子系统中一群接口。外观定义了一个高层接口，让子系统更容易使用。</li>
</ol>
<h1 id="5-OO原则-“最少知识”原则-墨忒耳法则"><a href="#5-OO原则-“最少知识”原则-墨忒耳法则" class="headerlink" title="5. OO原则:“最少知识”原则(墨忒耳法则)"></a>5. OO原则:“最少知识”原则(墨忒耳法则)</h1><h2 id="5-1-原则内容"><a href="#5-1-原则内容" class="headerlink" title="5.1. 原则内容"></a>5.1. 原则内容</h2><ol>
<li>只和你的，密友谈话。</li>
<li>也就是说你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并且注意他们是怎么交互的。</li>
<li>总而言之，减少类与类之间的耦合性。</li>
</ol>
<h2 id="5-2-如何做到这一点呢？"><a href="#5-2-如何做到这一点呢？" class="headerlink" title="5.2. 如何做到这一点呢？"></a>5.2. 如何做到这一点呢？</h2><ol>
<li>我们在该对象的方法中，应该调用属于以下范围的方法:<ol>
<li>该对象本身</li>
<li>被当做方法参数传递进来的对象</li>
<li>此方法所创建或实例化的任何对象</li>
<li>对象的任何组件</li>
</ol>
</li>
<li>一个简单的例子:</li>
</ol>
<img src="img\wg-3.png">

<h2 id="5-3-最少知识原则弊端"><a href="#5-3-最少知识原则弊端" class="headerlink" title="5.3. 最少知识原则弊端"></a>5.3. 最少知识原则弊端</h2><ol>
<li>虽然这个原则有力的减少了对象之间的依赖，但是这个原则依旧会导致软件“包装”类的增加。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/04/软件工程设计模式/适配器模式与外观模式/" data-id="ck1c5r1rv0006lowlqwwdh79l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/10/04/软件工程设计模式/设计模式入门/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/04/软件工程设计模式/适配器模式与外观模式/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/10/04/软件工程设计模式/设计模式入门/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/10/04/软件工程设计模式/观察者模式/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/10/04/软件工程设计模式/状态模式/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/10/04/软件工程设计模式/装饰者模式/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>