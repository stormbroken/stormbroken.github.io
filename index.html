<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/128.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.ico?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.ico?v=7.4.1">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222">
  <link rel="alternate" href="/atom.xml" title="Stormbrokenの博客" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="没有什么能够阻挡一直学习的心。">
<meta property="og:type" content="website">
<meta property="og:title" content="Stormbrokenの博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Stormbrokenの博客">
<meta property="og:description" content="没有什么能够阻挡一直学习的心。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stormbrokenの博客">
<meta name="twitter:description" content="没有什么能够阻挡一直学习的心。">
  <link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Stormbrokenの博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Stormbrokenの博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">留下生活学习的点点滴滴</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
      
        
      
        
      
        
      
    

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
      
        
      
        
      
        
          
        
      
    

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">3</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
      
        
      
        
          
        
      
        
      
    

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">3</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
      
        
          
        
      
        
      
        
      
    

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">23</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_类/" class="post-title-link" itemprop="url">java学习笔记 之 类</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：14:09:09" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol>
<li>类的定义：是描述相同事物的集合，以概要的方式描述了相同事物集合中的所有元素，但却允许类中的每一个实体元素可以在非本质特征上变化</li>
<li>另一种定义：面向对象程序设计中最基本的概念，定义了一个事物的抽象特征，定义了事物的属性和对属性的操作（行为）。是一种抽象数据类型，即某类数据结构和其所具有行为的集合。<br><code>class</code>关键词。</li>
</ol>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ol>
<li>类是对某个对象的定义</li>
<li>类包含相关对象的动作方式的信息</li>
<li>引用类的代码运行时，类的新实例对象就在内存中创建了</li>
<li>类应当有单一职责</li>
</ol>
<h2 id="创建类的原因"><a href="#创建类的原因" class="headerlink" title="创建类的原因"></a>创建类的原因</h2><ol>
<li>对现实世界中对象的建模</li>
<li>对抽象对象建模</li>
<li>降低复杂度</li>
<li>隔离复杂度</li>
<li>隐藏实现细节</li>
<li>限制变化影响的范围</li>
<li>创建中心控制点</li>
</ol>
<h2 id="类创建在堆上，类的成员"><a href="#类创建在堆上，类的成员" class="headerlink" title="类创建在堆上，类的成员:"></a>类创建在堆上，类的成员:</h2><ul>
<li>成员变量</li>
<li>成员方法</li>
</ul>
<h2 id="使用的功能性关键字"><a href="#使用的功能性关键字" class="headerlink" title="使用的功能性关键字"></a>使用的功能性关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>返回值</td>
<td>返回一个值</td>
</tr>
<tr>
<td><code>return</code></td>
<td>提供返回值</td>
</tr>
<tr>
<td><code>extends</code></td>
<td>表示继承关系</td>
</tr>
<tr>
<td><code>new</code></td>
<td>用于新建</td>
</tr>
<tr>
<td><code>.</code></td>
<td>用来引用访问类内部成员</td>
</tr>
</tbody></table>
<h2 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h2><p>1.java的对象不具备和基本数据类型相同的生命周期。<br>2.java的对象在解除引用后需要考虑如何释放内存。  </p>
<h2 id="外部类的调用"><a href="#外部类的调用" class="headerlink" title="外部类的调用"></a>外部类的调用</h2><p>1.关键字：<code>import</code><br>2.更加常见的是同时导入一个类的所有方法。 </p>
<h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><ol>
<li>方法名称和类名相同，参数不同，没有返回值</li>
<li>构造方法用于初始化一个类</li>
</ol>
<h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><ol>
<li>不可变字符串</li>
<li>java对于字符串的特殊处理：<ol>
<li>两种定义方式：<ul>
<li><code>String name = &quot;Tom&quot;</code>这样子不会新建内存</li>
<li><code>String name = new String(&quot;Tom&quot;)</code></li>
</ul>
</li>
<li>你在赋值时<code>name = &quot;Bob&quot;</code>,虚拟机不改变原来的对象，生成一个新的String对象，让name指向他，之后被解引用的会被回收。</li>
<li>使用<code>+</code>来生成字符串是一个非常浪费时间的操作<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3></li>
</ol>
</li>
<li>StringBuffer:支持多线程<ol>
<li>创建一个新的对象<code>StringBuffer sb = new StringBuffer(string.length*times//可选)</code></li>
<li>添加方法<code>.append()</code></li>
</ol>
</li>
<li>StringBuilder:不支持多线程<ol>
<li>创建一个新对象<code>StringBuilder name = new StringBuilder()</code></li>
<li>添加方法<code>.append()</code></li>
</ol>
</li>
</ol>
<h3 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h3><h3 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h3><ol>
<li><a href="https://blog.csdn.net/soft_zzti/article/details/79811923" target="_blank" rel="noopener">统一建模语言（UML)</a><br>name + instance variables + methods <blockquote>
<p>UML：  </p>
</blockquote>
<ol>
<li>分为四层，使用抽象概念（接口和继承）</li>
<li>可以在毕业设计中使用</li>
</ol>
</li>
<li>空心三角和实心直线表示继承</li>
<li>虚线表示抽象</li>
</ol>
<h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><ol>
<li>关键字<code>abstract</code></li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>有一些类不应该实例化</li>
<li>抽象类本身没有用，除非他被继承，有了子类。抽象类的子类可以实例化。</li>
<li>非抽象类中不可以有抽象方法</li>
<li>抽象类中可以有非抽象方法(非抽象方法表示已经被实现了)</li>
</ol>
<h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ol>
<li>抽象方法的存在就是为了多态</li>
<li>具体的类必须实现所有的抽象方法</li>
<li>实现抽象方法就像子类覆盖父类方法一样</li>
</ol>
<h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><ol>
<li>类的初始化的步骤<ol>
<li>加载：由类加载器执行，查找字节码，并创建一个Class对象</li>
<li>链接：验证字节码，为静态域分配空间(只是分配，并不初始话该存储空间)，解析该类创建所需要的对其他类的应用</li>
<li>初始化：首先执行静态初始化块static，初始化静态变量，执行静态方法(如构造方法)<ul>
<li>先加载直到加载到本身的父类</li>
<li>然后进行逐一的静态初始化</li>
<li>对于所有变量进行初始化</li>
<li>调用父类构造函数</li>
<li>局部变量按照字面顺序被初始化</li>
<li>剩下的部分的构造函数的运行</li>
</ul>
</li>
</ol>
</li>
<li>可能对了执行初始化的操作:<ol>
<li>创建一个java类的实例对象</li>
<li>调用了一个java类的静态方法</li>
<li>为类或接口中的静态域赋值</li>
<li>访问类或接口中声明的静态域，并且该域的值不是常值变量</li>
<li>在一个顶层的java类中执行assert语句</li>
<li>调用Class类和反射API中进行反射操作</li>
</ol>
</li>
<li>注意:当访问一个java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化</li>
</ol>
<h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><ol>
<li>所有变量先初始化，优先于构造方法</li>
<li>先初始化静态变量，然后是非静态的</li>
<li>静态变量按照字面顺序进行初始化<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2></li>
<li>private:仅可以由包含该成员变量或者成员方法的类访问，用于防止对象的成员变量被非法修改或者某些仅供对象自身使用的方法。</li>
<li>public：可以被所有类访问，用于对外提供的服务</li>
<li>protected：对于自己的子类是可见的</li>
<li>默认权限：可以被同一个包中的其他类访问。同一个包中的类名不可重复。所有没有显示指定所属包的类都位于同一个包中。</li>
</ol>
<h1 id="基本数据类型的包装类"><a href="#基本数据类型的包装类" class="headerlink" title="基本数据类型的包装类"></a>基本数据类型的包装类</h1><ol>
<li>我们在实际使用中经常需要将基本数据转化成对象，便于操作。</li>
<li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型相应的类统称为包装类</li>
<li>包装类</li>
</ol>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>1. java中每个基本数据类型都有一个对应的封装类</td>
<td></td>
</tr>
<tr>
<td>2. 封装类包含的值可以通过equals()进行比较</td>
<td></td>
</tr>
<tr>
<td>3. 封装类包含的值不可以通过value()进行比较</td>
<td></td>
</tr>
<tr>
<td>4. 封装类除了Character类外，都可以作为构造方法的实参创建实例</td>
<td></td>
</tr>
</tbody></table>
<h2 id="包装类的用途"><a href="#包装类的用途" class="headerlink" title="包装类的用途"></a>包装类的用途</h2><ol>
<li>包装类包含每种数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</li>
<li>提供了基本类型之间的转化方法、基本类型和对象和字符串之间相互转化的方法。</li>
</ol>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><ol>
<li>自动装箱过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中</li>
<li>自动拆箱过程：每当需要一个值时，被装箱对象中的值就被自动的提取出来，没必要再去调用intValue()和doubleValue()方法。</li>
<li>实际上我们的赋值语句是这样子。<code>Integer i = 100; -&gt; Integer i  = new Integer(100);</code></li>
</ol>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ol>
<li>内部类可以使用外部所有方法与变量，就算是私有的也一样</li>
<li>内部类提供了在一个类中实现同一接口的多次机会</li>
</ol>
<h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><ol>
<li>多态</li>
<li>实现：一个类和一个接口</li>
<li>聚合：7个队员组成1个球队<ul>
<li>指新类中采用已有类的对象作为其成员变量，并增加其他的成员变量来表示其属性</li>
</ul>
</li>
<li>继承</li>
<li>关联：你和你的老师</li>
<li>泛化:某些类之间存在一般元素和特殊元素的关系</li>
<li>依赖：一种使用关系，表现为一样事物的改变会影响到使用它的其他事物。</li>
<li>组合：大体同聚合，但是部分必须依赖整体而存在，比如人和大脑</li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_实体类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_实体类/" class="post-title-link" itemprop="url">java学习笔记 之 部分实体类</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:58:24" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<h1 id="字符串相关类"><a href="#字符串相关类" class="headerlink" title="字符串相关类"></a>字符串相关类</h1><ol>
<li>字符串是不可变类，本质上是按照字符数组存储的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello"</span>;</span><br><span class="line">String b = <span class="string">"hello"</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"hi"</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">"hi"</span>);</span><br><span class="line"><span class="keyword">char</span>[] e = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>&#125;;</span><br><span class="line">a==b;<span class="comment">//true</span></span><br><span class="line">c==d;<span class="comment">//false</span></span><br><span class="line">a==e;<span class="comment">//编译错误</span></span><br><span class="line">a.equals(e);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h2><ol>
<li>String类对象保存不可修改的Unicode字符序列</li>
<li>String类的下述方法能创建并返回一个新的String对象</li>
<li>功能性方法：endsWith、startsWith、indexOf、lastIndexOf、equals、equalsIgnoreCase、compareTo</li>
<li>其他方法:charAt、length、replace()</li>
</ol>
<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><ol>
<li>StringBuffer类：<ol>
<li>构造方法：<ol>
<li><code>StringBuffer()</code>:创建一个字符序列为空的StringBuffer对象</li>
<li><code>StringBuffer(String str)</code>:创建一个把与String对象str相同的字符序列</li>
</ol>
</li>
<li>其他方法：<ol>
<li>append()方法：想StringBuffer对象添加字符序列</li>
<li>delete(int start,int end):删除从start开始到end-1为止的一端字符序列，返回对象引用</li>
<li>deleteCharAt(int index):删除位于序列指定位置上的char</li>
<li>insert(int offset,String str):可以在指定位置上插入字符序列等</li>
<li>insert(int offest,double d):插入一个浮点数，提供自动转化</li>
<li>setCharAt(int index，char ch):在指定位置上插入指定字符</li>
</ol>
</li>
</ol>
</li>
<li>区分String和StringBuffer和StringBuilder：<ol>
<li>String：不可变字符序列</li>
<li>StringBuffer：可变字符序列，并且线程安全，但是效率低</li>
<li>StringBuilder：可变字符序列，线程不安全，但是效率高</li>
</ol>
</li>
</ol>
<h1 id="时间相关的处理类"><a href="#时间相关的处理类" class="headerlink" title="时间相关的处理类"></a>时间相关的处理类</h1><h2 id="Date时间类"><a href="#Date时间类" class="headerlink" title="Date时间类"></a>Date时间类</h2><ol>
<li>来源：java.util.Date</li>
<li>表示一个特定的瞬间，精确到毫秒</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol>
<li><code>Date()</code>:分配一个Date对象，并初始化此对象为当前的日期和时间精确到毫秒</li>
<li><code>Date(Long date)</code>:分配Date对象并初始化此对象，以表示从标准基准时间，即1970年1月1日00:00:00 GMT以指定毫秒数</li>
</ol>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table>
<thead>
<tr>
<th>返回值</th>
<th>函数名</th>
<th>函数意义</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>after(Date when)</td>
<td>测试该日期是否在指定日期以后</td>
</tr>
<tr>
<td>Boolean</td>
<td>before(Date when)</td>
<td>测试该日期是否在指定日期之前</td>
</tr>
<tr>
<td>Boolean</td>
<td>equals(Date when)</td>
<td>比较两个日期的相等性，重写的方法</td>
</tr>
<tr>
<td>Long</td>
<td>getTime()</td>
<td>返回自1970年1月1日00:00:00 GMT以来的</td>
</tr>
<tr>
<td>String</td>
<td>toString()</td>
<td>把此Date对象转换为各种形式的String</td>
</tr>
</tbody></table>
<h2 id="DateFormat类和SimpleDateFormat类"><a href="#DateFormat类和SimpleDateFormat类" class="headerlink" title="DateFormat类和SimpleDateFormat类"></a>DateFormat类和SimpleDateFormat类</h2><ol>
<li><p>构造:<code>SimpleDateFormat a = new SimpleDateFormat(&quot;YYYY-MM-dd&quot;)</code></p>
</li>
<li><p>按照构造中的格式转化生成相应Date对象：<code>Date date = a.parse(&quot;2019-6-21&quot;)</code></p>
</li>
<li><p>具体的格式化字符介绍</p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>内涵</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>年代标志符</td>
</tr>
<tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>h</td>
<td>时，12进制，1-12</td>
</tr>
<tr>
<td>H</td>
<td>时，24进制，0-23</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
</tr>
<tr>
<td>E</td>
<td>星期</td>
</tr>
<tr>
<td>D</td>
<td>一年中的第几天</td>
</tr>
<tr>
<td>F</td>
<td>一月中第几个星期几</td>
</tr>
<tr>
<td>w</td>
<td>一年中第几个星期</td>
</tr>
<tr>
<td>W</td>
<td>一月中的第几个星期</td>
</tr>
<tr>
<td>a</td>
<td>上午/下午 标记符</td>
</tr>
<tr>
<td>k</td>
<td>时，一天中(1-24)</td>
</tr>
<tr>
<td>K</td>
<td>时，在上午或下午(0-11)</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
</tr>
<tr>
<td>2. 使用的语句：<code>SimpleDateFormat a = new SimpleDateFormat(&quot;yyyy&quot;)</code></td>
<td></td>
</tr>
<tr>
<td>3. 转化成为字符串：<code>a.format(now)</code></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Calendar日历类"><a href="#Calendar日历类" class="headerlink" title="Calendar日历类"></a>Calendar日历类</h2><ol>
<li>他是一个抽象类，定义了一些特定的日历字段之间的转换用的方法</li>
<li>注意月份的表示中：一月是0</li>
</ol>
<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><ol>
<li>来源:java.lang.Math</li>
<li>相应的方法：<ul>
<li>abs:绝对值</li>
<li>acos,asin,atan,cos,sin,tan：各种三角函数</li>
<li>sqrt：平方根</li>
<li>pow(double a,double b)：a的b次幂</li>
<li>log自然对数</li>
<li>exp e为底指数</li>
<li>max(double a,double b)</li>
<li>min(double a,double b)</li>
<li>random()：返回0.0到1.0的随机数</li>
<li>long round(double a)：double类型的数据a转化为long类型</li>
<li>toDegrees(double angrad)：弧度-&gt;角度</li>
<li>toRadians(double angdeg)：角度-&gt;弧度</li>
</ul>
</li>
</ol>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><ol>
<li>来源：java.io.File类</li>
<li>常见的构造方法：<code>public File(String pathname)</code><ul>
<li>构造方法参数可以为String、File、URL</li>
</ul>
</li>
<li>方法：<ul>
<li>public boolean canRead()</li>
<li>public boolean canWrite()</li>
<li>public boolean exists()     </li>
<li>public boolean isDirectory()</li>
<li>public boolean isFile()     </li>
<li>public boolean isHidden()</li>
<li>public long lastModified() </li>
<li>public long length()</li>
<li>public String getName()   </li>
<li>public String getPath()</li>
<li>public String getAbsolutePath()</li>
<li>public boolean delete()</li>
<li>public boolean mkdir():创建新的文件夹</li>
</ul>
</li>
<li>equals()方法在这个类中被重写，只有两个对象的内容和类型一致时返回</li>
</ol>
<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><ol>
<li>只能够取特定值中的一个</li>
<li>使用enum关键字</li>
<li>所有的枚举类型都隐形地继承自java.lang.Enum。而每个被枚举的变量都被默认为public static final的</li>
<li>建议使用一组常量的时候，使用枚举类型</li>
<li>尽量避免使用枚举的高级特性</li>
</ol>
<h1 id="Applet类"><a href="#Applet类" class="headerlink" title="Applet类"></a>Applet类</h1><ol>
<li>是一个采用java编程语言编写的小应用程序</li>
<li>可以读取客户端部分系统变量</li>
<li>不可以读取客户端文件</li>
<li>不可以在客户端主机上创建新文件</li>
<li>不可以在客户端装载程序库</li>
<li><code>&lt;applet code=TestApplet.class width=100 height=100&gt;&lt;/applet&gt;</code></li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_面向对象编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_面向对象编程/" class="post-title-link" itemprop="url">java学习笔记 之 OO</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:58:05" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>

<p><strong>面向对象编程(职责&amp;协作)</strong></p>
<ol>
<li>对象定义：是类的实例，有具体的属性，可以执行具体的行为。    <h1 id="职责-功能"><a href="#职责-功能" class="headerlink" title="职责(功能)"></a>职责(功能)</h1></li>
<li>职责：可以理解为对象的功能<ul>
<li>通过对需求的分析，寻找系统所需的功能，然后通过设计确定每个类的职责。</li>
</ul>
<ol>
<li>单一职责原则：(SRP):就一个类而言，应该仅有一个引起它变化的原因。</li>
<li>需求：是系统必须具有的特征，或者是客户可接受的、系统必须满足的约束，即我们要解决的“问题”。</li>
<li>场景：一种人们将做什么的陈述性描述，以及人们试图利用计算机系统和应用程序经验的陈述性描述。描述一个用户和系统之间交互的一系列步骤。场景是需求获取中的一种重要手段。一个场景是来自单一参与者的、具体的、关注点集中的系统单一特征的非形式化描述。</li>
</ol>
</li>
<li>数据职责和行为职责在一起，将职责合理分配</li>
<li>数据和行为之间存在于一定的关系</li>
<li>类和对象：<ol>
<li>类-职责的抽象</li>
<li>对象-职责的实现</li>
<li>类和对象是抽象与具体关系</li>
</ol>
</li>
<li>给对象分配责任的策略：<ol>
<li>分配所有重要方面</li>
<li>寻找需要执行的动作以及需要为何和生成的信息</li>
</ol>
</li>
<li><strong>数据职责是方法要用到的数据</strong></li>
<li>行为职责</li>
</ol>
<h1 id="世界观的变化"><a href="#世界观的变化" class="headerlink" title="世界观的变化"></a>世界观的变化</h1><ol>
<li>想法的变化：从原来函数之间的调用到现在的有职责的对象之间的交互</li>
<li>视角的变化：<ol>
<li>行为视角：结构化方法</li>
<li>数据视角：数据为中心方法</li>
<li>职责方法：面向对象方法</li>
</ol>
</li>
<li>在这种思路下，我们使用类来描述对象，使用类的方法来定义他们的行为</li>
</ol>
<h1 id="对象-职责的实现"><a href="#对象-职责的实现" class="headerlink" title="对象(职责的实现)"></a>对象(职责的实现)</h1><ol>
<li>对象是什么：<ol>
<li>定义：<ol>
<li>是客观世界问题空间中的某个具体的事物</li>
<li>是软件系统解空间中的基本元素</li>
</ol>
</li>
<li>对象的特征：<ol>
<li>每个对象都保存着描述当前特征的信息</li>
<li>对象状态的改变必须通过调用方法来实现</li>
<li>每个对象都有唯一的身份，边坡是永远不同，状态也常常不同</li>
</ol>
</li>
</ol>
</li>
<li>对象的初始化:<ol>
<li>在方法甚至是构造方法之前初始化</li>
<li>优先初始化静态变量，静态变量按照文字顺序初始化,例子见pdf</li>
</ol>
</li>
<li>对象定义：是类的实例，有具体的属性，可以执行具体的行为。  <h1 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h1></li>
<li>CRC卡  <a href="https://baike.baidu.com/item/CRC卡/5702018?fr=aladdin" target="_blank" rel="noopener">详见</a></li>
<li>类图</li>
<li>UMC：统一化建模语言</li>
<li>用例分析</li>
</ol>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ol>
<li>封装三原则：<ol>
<li>数据和行为放置在一块（在一起）</li>
<li>使用职责驱动型设计来决定如何确定一个类中的数据和行为</li>
<li>职责应当具有完备性</li>
</ol>
</li>
<li>是防御性编程的范例之一</li>
<li>封装的作用：<ol>
<li>隐藏类的实现细节，将类对外提供服务的接口和内部的具体实现进行分离，有助于在不影响对类使用的情况下修改类内部的实现</li>
<li>控制对成员变量的访问（可以在对成员变量的访问中加入数据检查和控制逻辑，限制对成员变量不合理的操作）</li>
</ol>
</li>
</ol>
<h2 id="类的职责和封装"><a href="#类的职责和封装" class="headerlink" title="类的职责和封装"></a>类的职责和封装</h2><ol>
<li>责任是指对象持有、维护特定数据并基于该数据进行操作的能力。</li>
<li>面向对象三要素：<ol>
<li>封装</li>
<li>继承</li>
<li>多态<h3 id="数据职责："><a href="#数据职责：" class="headerlink" title="数据职责："></a>数据职责：</h3><ul>
<li>表征对象的本质特征</li>
<li>行为（计算）所需要的数据<h3 id="行为职责"><a href="#行为职责" class="headerlink" title="行为职责:"></a>行为职责:</h3></li>
<li>表征对象的本质行为</li>
<li>拥有数据所应该体现的行为</li>
</ul>
</li>
</ol>
</li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_接口/" class="post-title-link" itemprop="url">java学习笔记 之 接口</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:57:06" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<p><strong>接口</strong></p>
<ol>
<li>为了实现外部定义与内部实现彻底分离，达到”相同接口，多种实现”的目的，java小红提供了”接口”<h1 id="Deadly-Dlamond"><a href="#Deadly-Dlamond" class="headerlink" title="Deadly Dlamond"></a>Deadly Dlamond</h1></li>
<li>java不支持多重继承，但是c++支持多重继承</li>
<li>而java允许多个接口</li>
</ol>
<h1 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h1><ol>
<li>定义方式: <code>public interface name{}</code></li>
<li>使用方式: <code>public class name implements name</code></li>
</ol>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol>
<li>纯抽象类，没有任何方法的定义，仅仅持有这些方法的声明<ol>
<li>接口中的数据成员在自动是static和final的，它们不能是空final，但是可以被非常量表达式初始化。</li>
<li>其中的抽象方法需要全部的实现<ol>
<li>接口方法在方法表中的位置不是固定的，调用方法需要查找<ol>
<li>invokeinterface会相对慢一些：需要在方法表中去查找</li>
</ol>
</li>
<li>接口方法和抽象方法不可以相互替代<ol>
<li>接口可以被类和接口多继承</li>
<li>但是抽象类只能被单继承</li>
<li>接口中没有this指针，没有构造函数，没有实例字段，无法保存状态，而抽象方法就可以</li>
<li>抽象类不能在java8中使用lambda表达式</li>
<li>在设计理念上，接口反映的是”like-a”关系，抽象类反映的是”is-a”关系</li>
</ol>
</li>
</ol>
</li>
<li>接口可以被嵌套在类或其他接口中</li>
</ol>
</li>
<li>我们可以通过继承接口来扩展接口</li>
</ol>
<h1 id="具体类和接口的使用"><a href="#具体类和接口的使用" class="headerlink" title="具体类和接口的使用"></a>具体类和接口的使用</h1><ol>
<li>显示地使用具体的类<ol>
<li>锁定某个具体的实现</li>
<li>丧失了可扩展性</li>
<li>丧失了灵活性</li>
</ol>
</li>
<li>按接口编程<ol>
<li>增加开发的可并行性</li>
<li>栈：后入先进</li>
<li>队列：先进先出</li>
</ol>
</li>
</ol>
<h1 id="链表的例子"><a href="#链表的例子" class="headerlink" title="链表的例子"></a>链表的例子</h1><ol>
<li>链表无法进行快速的查询，链表只能从头遍历</li>
<li>使用集合给的比要的要多</li>
<li>增加了耦合性</li>
<li>增加了出错了的概率</li>
</ol>
<h1 id="栈的例子"><a href="#栈的例子" class="headerlink" title="栈的例子"></a>栈的例子</h1><ol>
<li>Monitorable和stack组合</li>
<li>你依赖的东西是否有问题</li>
<li>不同类型的栈</li>
</ol>
<h1 id="字节码解释"><a href="#字节码解释" class="headerlink" title="字节码解释"></a>字节码解释</h1><ol>
<li>详见PPT</li>
</ol>
<h1 id="default-默认方法"><a href="#default-默认方法" class="headerlink" title="default 默认方法"></a>default 默认方法</h1><ol>
<li>default关键字只能在接口中使用(使用在switch中的default不能用在抽象类中)</li>
<li>这个用于解决为借口添加新方法而又不会破坏已有方法的实现，为升级旧接口且保持向后兼容提供了途径</li>
<li>默认方法的继承问题：可以重写，参见PPT</li>
<li>接口继承行为发生冲突时的解决规则：<ol>
<li>使用super来调用父类中的方法</li>
<li>当接口继承行为发生冲突时的另一个规则是，类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的。</li>
</ol>
</li>
<li>接口方法不能重写:Object类中的<code>equals、hashCode、toString</code></li>
<li>接口中的静态方法必须是public的，这个修饰符可以省略，但是static修饰符不可以被省略<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hi."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_高阶函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_高阶函数/" class="post-title-link" itemprop="url">java学习笔记 之 高阶函数</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:56:11" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>

<p><strong>java8以后的高阶函数</strong></p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><ol>
<li>高阶函数是指接受另一个函数作为参数，或返回一个函数的函数。</li>
</ol>
<h2 id="高阶函数的例子"><a href="#高阶函数的例子" class="headerlink" title="高阶函数的例子"></a>高阶函数的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;?&gt; numUp = <span class="function">Stream <span class="title">of</span> <span class="params">(list)</span>.<span class="title">map</span><span class="params">(function)</span></span></span><br><span class="line"><span class="function">Stream&lt;?&gt; numbers </span>= <span class="function">Stream <span class="title">of</span> <span class="params">(list)</span>.<span class="title">filter</span><span class="params">(expr)</span></span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/rongrong_love_lc/article/details/72845528" target="_blank" rel="noopener">详见</a></p>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_方法/" class="post-title-link" itemprop="url">java学习笔记 之 方法</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:57:25" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<p><strong>方法</strong></p>
<ol>
<li>方法的概念：<ul>
<li>物理角度：指令块</li>
<li>逻辑角度：抽象指令单元</li>
<li>语义角度：行为</li>
</ul>
</li>
<li>分类：<ul>
<li>类的行为：方法</li>
<li>对象的行为：方法</li>
</ul>
</li>
</ol>
<h1 id="命名法"><a href="#命名法" class="headerlink" title="命名法"></a>命名法</h1><ol>
<li>第一个字母小写，之后的首字母大写。</li>
<li>一般用动词，或者动宾短语</li>
<li>和boolean相关的，isValid</li>
</ol>
<h1 id="方法的所有属性"><a href="#方法的所有属性" class="headerlink" title="方法的所有属性"></a>方法的所有属性</h1><ol>
<li>类的行为：<ol>
<li>静态方法</li>
<li>类名来调用</li>
</ol>
</li>
<li>对象的行为：<ol>
<li>成员方法</li>
<li>对象的引用来调用</li>
</ol>
</li>
</ol>
<h1 id="方法的意义"><a href="#方法的意义" class="headerlink" title="方法的意义"></a>方法的意义</h1><ol>
<li>逻辑封装</li>
<li>重用</li>
<li>可修改性</li>
</ol>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li>返回值</li>
<li>方法名</li>
<li>参数<ul>
<li>个数</li>
<li>类型</li>
<li>顺序</li>
</ul>
</li>
<li>抛出的异常</li>
</ul>
<h1 id="运行期："><a href="#运行期：" class="headerlink" title="运行期："></a>运行期：</h1><ul>
<li>程序执行的时间段</li>
<li>方法调用<ul>
<li>同步<ul>
<li>调用的方法和被调用的方法相关</li>
</ul>
<ol>
<li>每个方法只有一个入口。</li>
<li>被调用方法执行时，调用方法停止</li>
<li>调用结束后，程序控制权交换</li>
</ol>
</li>
<li>异步<ul>
<li>调用方法和被调用方法不相关</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h1><ul>
<li>public</li>
<li>private</li>
<li>protected</li>
<li>缺省（在一个包中）<h1 id="成员方法的声明"><a href="#成员方法的声明" class="headerlink" title="成员方法的声明"></a>成员方法的声明</h1>修饰词 返回类型 方法名称（参数列表){<br>方法<br>}  </li>
</ul>
<h1 id="成员方法的调用机制"><a href="#成员方法的调用机制" class="headerlink" title="成员方法的调用机制"></a>成员方法的调用机制</h1><ol>
<li>方法被同步调用的特性<ol>
<li>每个方法都只有一个入口</li>
<li>当执行被调用的方法的时候，调用方法暂停</li>
<li>当方法结束时，程序的控制权交还给调用处</li>
</ol>
</li>
<li>封装和闭包</li>
</ol>
<h1 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h1><ol>
<li>接口中的方法可以重载，但需要实现全部方法，也就是接口继承时<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2></li>
</ol>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ol>
<li>if</li>
<li>if else</li>
<li>switch(c)</li>
<li>switch(string)</li>
</ol>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol>
<li>while</li>
<li>do while</li>
<li>for </li>
<li>for each syntax</li>
<li>特殊的关键字<ol>
<li>break</li>
<li>continue</li>
<li>return</li>
<li>exit:<br>返回0:返回正常值<br>返回-1：程序异常跳出<h1 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h1><code>return</code>返回值<br><code>exit</code>退出程序运行，返回0，正常，-1，错误退出</li>
</ol>
</li>
</ol>
<h1 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h1><h2 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写(Override)"></a>方法重写(Override)</h2><ol>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变</li>
<li>好处在于：子类可以根据需要特定于自己的行为</li>
<li>重写方法不能抛出新的检查异常或者比重写方法申明更加宽泛异常重写的方法要求被</li>
<li>要求原来的父类中必须有这个方法</li>
<li>方法的重写规则：<ol>
<li>参数列表必须完全与被重写方法的相同</li>
<li>返回类型可以与被重写方法的类型不相同，但是必须是父类返回值的派生类</li>
<li>访问权限不能比父类中重写的方法的访问权限更低。<code>public&lt;protected</code></li>
<li>父类的成员方法只能被它的子类重写</li>
<li>声明为final的方法不能被重写</li>
<li>声明为static的方法不能被重写，但是可以被再次声明</li>
<li>子类可以重写父类的方法：<ol>
<li>子类和父类同包时，可以重写所有除了声明为private和final的方法</li>
<li>子类和父类不同包时，那么子类只能重写父类声明为public和protected的非final方法</li>
</ol>
</li>
<li>构造方法不能被重写</li>
<li>如果不能继承一个方法，则不能重写这个方法</li>
<li>重写方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常<ul>
<li>不能抛出新的</li>
<li>不能抛出更广泛的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">programmer</span>()</span>&#123;</span><br><span class="line">    <span class="function">programmer <span class="title">game</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NJUCoder</span> <span class="keyword">extends</span> <span class="title">programmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">game</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">//编译错误，不能有不同返回值的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h2><ol>
<li>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>
<li>最常用的是构造器的重载</li>
<li>每个重载的方法必须有独一无二的参数类型列表</li>
<li>特点：<ul>
<li>变量类型</li>
<li>变量数量</li>
<li><strong>在同一个类内的不同的方法，只不过恰好名字相同。</strong></li>
<li>非法重载：<ol>
<li>只有标识符不同</li>
<li>只有返回值不同</li>
</ol>
</li>
</ul>
</li>
<li>代码重载规则：<ol>
<li>被重载的方法必须改变参数列表(参数数量或者类型不一样)</li>
<li>被重载的方法可以改变返回类型</li>
<li>被重载的方法可以改变访问修饰符</li>
<li>被重载方法可以声明新的或更广的检查异常</li>
<li>方法能够在同一类中或者在一个子类中被重载</li>
<li>无法以返回值类型作为重载函数的区分标准</li>
</ol>
</li>
</ol>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问</td>
<td>可以修改</td>
<td>一定不能做更严格的限制</td>
</tr>
</tbody></table>
<h1 id="方法调用的字节码"><a href="#方法调用的字节码" class="headerlink" title="方法调用的字节码"></a>方法调用的字节码</h1><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><ol>
<li>invokestatic:静态方法调用</li>
<li>invokespecial:实例构造器的<code>&lt;init&gt;</code>方法，私有方法和父类方法</li>
<li>invokevirtual:虚方法</li>
<li>invokeinterface:接口方法，会在运行时再确定一个实现此接口的对象</li>
<li>invokedynamic:会在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户有更高的自由度</li>
</ol>
<h2 id="overloading优先级"><a href="#overloading优先级" class="headerlink" title="overloading优先级"></a>overloading优先级</h2><ol>
<li>char&gt;int&gt;long&gt;character&gt;serializable&gt;object&gt;char…</li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_泛型/" class="post-title-link" itemprop="url">java学习笔记 之 泛型</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:56:17" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>

<h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><ol>
<li>泛型:即参数化类型。</li>
<li>其本质是为了参数化类型(在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参来控制形参具体限制的类型)</li>
<li>泛型可以让部分错误在编译阶段可以被发现。</li>
</ol>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>泛型只在编译阶段是有效的，在编译之后，程序会采取泛型化的措施</li>
<li>总而言之:泛型类型在逻辑上可以看成十多个不同的类型，但实际上都是相同的基本类型。</li>
</ol>
<h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><ol>
<li>三种使用方式:泛型化、泛型接口和泛型方法</li>
</ol>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ol>
<li><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。</p>
</li>
<li><p>相应的泛型类的例子:list、Set、Map。</p>
</li>
<li><p>泛型类的最基本写法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基本的泛型类的示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型类:泛型的时候传入泛型实参，则会根据传入的泛型实参做相应的限制，这时候才会应起到的限制作用。</p>
</li>
</ol>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><ol>
<li>泛型接口与泛型类的定义及使用基本相同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考网页"><a href="#参考网页" class="headerlink" title="参考网页"></a>参考网页</h1><p><a href="https://www.cnblogs.com/coprince/p/8603492.html" target="_blank" rel="noopener">参考</a></p>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_集合/" class="post-title-link" itemprop="url">java学习笔记 之 集合</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：14:06:06" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<p><strong>集合</strong></p>
<h1 id="哈希（类似于-python-dict"><a href="#哈希（类似于-python-dict" class="headerlink" title="哈希（类似于 python dict)"></a>哈希（类似于 python dict)</h1><ol>
<li>HashMap 是一个用于储存Key-Value键对的集合。每一个键值对叫Entry,分散存储在一个数组中，作为一个主干，初始值null</li>
</ol>
<h1 id="List类："><a href="#List类：" class="headerlink" title="List类："></a>List类：</h1><h2 id="常见的list的初始化方式"><a href="#常见的list的初始化方式" class="headerlink" title="常见的list的初始化方式"></a>常见的list的初始化方式</h2><ol>
<li><p>构造List后使用List.add初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用双括号语法</p>
<ul>
<li>相当于定义了匿名内部类，会损失效率</li>
<li>如果返回List到其他地方可能会引起内存泄露<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;String&gt;()&#123;&#123;</span><br><span class="line">   add(<span class="string">"a"</span>);</span><br><span class="line">   add(<span class="string">"b"</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用Arrays.asList的内部静态方法</p>
<ol>
<li>返回的是Arrays的静态内部类<ul>
<li>静态类继承自AbstractList，实现RandomAccess，内部使用数组来存储元素，但是不支持增删元素</li>
</ul>
</li>
<li>尽量避免使用int基本类型，和[]这种底层的数据结构，相应的应当尽量使用List和Integer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList  = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用高阶函数Stream(JDK8)</p>
<ol>
<li>略微有点大材小用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; List = Stream.of(<span class="string">"a"</span>,<span class="string">"b"</span>).collect(Collectors.toList())</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>使用Lists(JDK9)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="集合关系运算"><a href="#集合关系运算" class="headerlink" title="集合关系运算"></a>集合关系运算</h2><ol>
<li>求并集:<code>list1.addAll(list2)</code></li>
<li>求交集:<code>list1.retainAll(list2)</code></li>
<li>求补集:<code>list1.removeAll(list2)</code></li>
</ol>
<h1 id="Map类："><a href="#Map类：" class="headerlink" title="Map类："></a>Map类：</h1><ol>
<li>用于存储元素对(称作”键”和”对”)。</li>
<li>类型介绍：<ol>
<li>通用MAP</li>
<li>专用MAP</li>
<li>用于帮助我们实现自己的MAP类的抽象类</li>
</ol>
</li>
<li>类型区别<ol>
<li>HashMap:<em>最常用</em>  <blockquote>
<p>用HashCpde值存储数据，访问数据，非同步的 </p>
</blockquote>
</li>
<li>TreeMap:  <blockquote>
<p>能够把它保存的记录根据键值进行升序排序，也可以制定排序的比较器。<br>不允许Key的值为null.不同步.  </p>
</blockquote>
</li>
<li>Hashtable：  <blockquote>
<p>Key和value均不允许为null，它支持线程的同步，写入时较慢。  </p>
</blockquote>
</li>
<li>LinkedHashMap:  <blockquote>
<p>保存了记录的插入顺序，用Iterator遍历时，先得到的记录是先插入的。<br>Key和value不可以为空，非同步的。  </p>
</blockquote>
</li>
</ol>
</li>
<li>常用语法  </li>
</ol>
<table>
<thead>
<tr>
<th>代码</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</code></td>
<td>用于初识化一个链表</td>
</tr>
<tr>
<td><code>map.put(&quot;key1&quot;,&quot;value1&quot;);&quot;</code></td>
<td>用于插入元素</td>
</tr>
<tr>
<td><code>map.get(&quot;key1&quot;);</code></td>
<td>用于获取元素</td>
</tr>
<tr>
<td><code>map.remove(&quot;key1&quot;);</code></td>
<td>用于移除元素</td>
</tr>
<tr>
<td><code>map.clear</code></td>
<td>用于清空整个链表</td>
</tr>
<tr>
<td><code>map.Keyset()</code></td>
<td>用于增强for进行增强遍历(例子参见1)</td>
</tr>
<tr>
<td><code>map.entrySet()</code></td>
<td>用于增强for进行另一种增强遍历(例子参见2)</td>
</tr>
<tr>
<td><code>map.putAll(Map t)</code></td>
<td>将指定的Map中的所有映射复制到这个map</td>
</tr>
<tr>
<td><code>map.containsKey(Object key)</code></td>
<td>如果Map包含指定键的映射，返回true</td>
</tr>
<tr>
<td><code>map.containsValue(Object value)</code></td>
<td>如果map将一个或多个键映射到指定值，则返回true</td>
</tr>
<tr>
<td><code>map.isEmpty()</code></td>
<td>如果Map不包含键-值映射，则返回true</td>
</tr>
<tr>
<td><code>map.size()</code></td>
<td>返回Map中的键-值映射的数目</td>
</tr>
</tbody></table>
<ol>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">System.out.println(key + <span class="string">" ："</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">" ："</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<ol start="5">
<li>迭代可以直接进行迭代，也可以用迭代器进行迭代。  </li>
</ol>
<h1 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h1><ol>
<li>是数组队列，相当于动态数组，不同于Vector的是，这个类并不是线程安全的，也就是最好只在单线程中使用。</li>
<li>构造函数  </li>
</ol>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayList</code></td>
<td>默认构造函数</td>
</tr>
<tr>
<td><code>ArrayList(int capacity)</code></td>
<td>设置这个数组的默认大小，如果不够的话一次添加上一次容量的一半</td>
</tr>
<tr>
<td><code>ArrayList(Collection&lt;? extends E&gt; collection)</code></td>
<td>创建一个包含collection的ArrayList</td>
</tr>
<tr>
<td>3. API(常用)</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>add(E object)</td>
<td>添加项</td>
</tr>
<tr>
<td>boolean</td>
<td>addAll(collection&lt;? extends E&gt;collection)</td>
<td>移除全部项</td>
</tr>
<tr>
<td>void</td>
<td>clear()</td>
<td>清空</td>
</tr>
<tr>
<td>boolean</td>
<td>contains(Object object)</td>
<td>判断是否包含</td>
</tr>
<tr>
<td>boolean</td>
<td>containsAll(collection&lt;? extends E&gt;collection)</td>
<td>判断是否全部包含</td>
</tr>
<tr>
<td>boolean</td>
<td>equals(Object object)</td>
<td>判断是否相同</td>
</tr>
<tr>
<td>int</td>
<td>hashCode()</td>
<td>根据对象的地址或者字符串或者数字算出来的int型的数值</td>
</tr>
<tr>
<td>boolean</td>
<td>isEmpty()</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>boolean</td>
<td>remove(Object object)</td>
<td>移除元素</td>
</tr>
<tr>
<td>boolean</td>
<td>removeAll(collection&lt;? extends E&gt;collection)</td>
<td>移除全部这些元素</td>
</tr>
<tr>
<td>boolean</td>
<td>retainAll(collection&lt;? extends E&gt;collection)</td>
<td>取交集</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>返回这个链表的长度</td>
</tr>
<tr>
<td></td>
<td>get()</td>
<td>按照索引访问元素</td>
</tr>
<tr>
<td>&lt;a href = “<a href="https://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3308556.html</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>“&gt;查询详情</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h1><ol>
<li>实现自动增长的对象数组</li>
<li><a href="https://www.cnblogs.com/zheting/p/7708366.html" target="_blank" rel="noopener">详见</a></li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_继承和多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_继承和多态/" class="post-title-link" itemprop="url">java学习笔记 之 继承和多态</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：13:56:53" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<h1 id="java学习笔记之继承和多态"><a href="#java学习笔记之继承和多态" class="headerlink" title="java学习笔记之继承和多态"></a>java学习笔记之继承和多态</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>继承是指利用已有类的形式，并添加新的成员变量和方法来构建新的类。</li>
<li>父类不可以强制类型转换成子类</li>
<li>java单一继承，而不是多继承<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">            Base b = <span class="keyword">new</span> Base();</span><br><span class="line">            Sub s = (Sub) b;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; <span class="comment">//编译通过，但运行是出错</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="继承源起"><a href="#继承源起" class="headerlink" title="继承源起"></a>继承源起</h3><ol>
<li>避免重复代码</li>
<li>分类、抽象的概念</li>
<li>根父类：Object<ol>
<li>toString()方法</li>
<li>equals()方法</li>
<li>wait()方法</li>
</ol>
</li>
</ol>
<h3 id="继承特点"><a href="#继承特点" class="headerlink" title="继承特点"></a>继承特点</h3><ol>
<li>子类继承了父类所有成员变量和方法</li>
<li>继承可以增加成员变量和成员方法</li>
<li>继承可以覆盖父类的成员方法</li>
<li>继承不可以覆盖父类的成员变量<ul>
<li>父类中的方法如果是private，不能调用子类重写的方法</li>
</ul>
</li>
<li>重名方法会调用继承树最下方部分的方法</li>
<li>父类设置了一种契约，所有的子类都会承受这个契约</li>
<li><strong>任何一个子类对象都可以当做父类来看待</strong></li>
<li>子类写的和父类同名的方法算一个方法，是对父类的重写</li>
<li>子类变量可以被赋值给父类引用</li>
<li><strong>父类不可以强制类型转换成子类</strong></li>
</ol>
<h3 id="问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？"><a href="#问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？" class="headerlink" title="问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？"></a>问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？</h3><ol>
<li>能够继承父类的私有变量</li>
<li>但是不能直接访问父类的私有变量</li>
</ol>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ol>
<li>如果你在子类中重写了父类的方法，但是想要使用父类中未被重写的方法，那么使用super关键字来完成引用  </li>
<li>几个实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">father</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">son</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="IS-A-amp-amp-HAS-A-amp-amp-USES-A-amp-amp-OWNS-A"><a href="#IS-A-amp-amp-HAS-A-amp-amp-USES-A-amp-amp-OWNS-A" class="headerlink" title="IS-A&amp;&amp;HAS-A&amp;&amp;USES-A&amp;&amp;OWNS-A"></a>IS-A&amp;&amp;HAS-A&amp;&amp;USES-A&amp;&amp;OWNS-A</h3><ol>
<li>IS-A是继承机制</li>
<li>HAS-A是是否被继承机制</li>
<li>USES-A是依赖关系</li>
<li>HAS-A是关联关系</li>
<li>OWNS-A是聚合关系</li>
<li>IS-A-PART-OF是组合关系</li>
</ol>
<h3 id="父类对于子类的影响"><a href="#父类对于子类的影响" class="headerlink" title="父类对于子类的影响"></a>父类对于子类的影响</h3><ol>
<li>父类的接口的更改会影响所有的子类的接口。</li>
<li>子类继承父类的私有变量、接口等。</li>
<li>从构造方法开始，向上调用父类方法</li>
<li>编译器会自动帮你调用super()(也就是无参数的构造函数)，而如果写的话必须在开头</li>
<li>从接口来看：<ol>
<li>子类必须保持和父类同样的接口</li>
<li>子类必须继承了父类的实现</li>
<li>一旦父类脆弱发生变化，就会对子类造成很大的麻烦</li>
</ol>
</li>
</ol>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ol>
<li>一个类里面有一个属性，将一个fruit组合进入Apple中</li>
<li>允许你在新的类中设置子对象，组合是显式的这样做，而继承是隐式的这样做。</li>
<li>使用组合关系时，前端接口和后端接口没有直接关系，只要修改实现就好</li>
<li>组合主要用于想要在新类中使用现有类的功能而并不是它的接口的情形</li>
</ol>
<h2 id="对于继承和组合的选择"><a href="#对于继承和组合的选择" class="headerlink" title="对于继承和组合的选择"></a>对于继承和组合的选择</h2><ol>
<li>确保有继承关系</li>
<li>不要使用继承去完成代码的重载</li>
<li>确认父类方法的接口稳定性</li>
</ol>
<h2 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h2><ol>
<li>特点：<ol>
<li>对已有实现的修改</li>
<li>对新的实现的扩展</li>
<li>对实现的动态配置</li>
</ol>
</li>
</ol>
<h3 id="用户端代码"><a href="#用户端代码" class="headerlink" title="用户端代码"></a>用户端代码</h3><ol>
<li>特点：<ol>
<li>大量的</li>
<li>分散的</li>
<li>如何发生修改重新编译的话，是需要大量时间的<blockquote>
<p>不想要更改</p>
</blockquote>
</li>
</ol>
</li>
<li>构造方法没有多态</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol>
<li>多态是指多个成员变量或成员方法采用相同的标识符，并且在使用该标识符时确认应该使用哪个成员变量或成员方法。</li>
<li>所有类的父类:Object<ol>
<li><code>equals(Object o)</code>指示某个其他对象是否与此对象“相等”。 </li>
<li><code>getClass()</code>返回一个对象的运行时类。</li>
<li><code>hashCode()</code>返回该对象的哈希码值。</li>
<li><code>toString()</code>返回该对象的字符表示。</li>
</ol>
</li>
<li>多态的代价：Object不能添加Dog类型的变量。</li>
<li>编译时，编译器决定你是否能调用某个方法<ul>
<li>依据引用变量的类型，而不是引用变量指向的对象的类型</li>
</ul>
</li>
<li>执行时，JVM虚拟机决定实际那个方法被调用<ul>
<li>依据实际引用变量指向的对象的类型</li>
</ul>
</li>
<li>多态的思想:分离”做什么”和”怎么做”，从另一角度将接口和实现分离开来。</li>
<li>Overriding规则:<ol>
<li>参数必须一致，返回值必须兼容</li>
<li>方法的可达性不可降低(private、public)</li>
<li>不可以覆盖私有方法，因为父类私有方法自动添加final</li>
</ol>
</li>
<li>Overloading<ol>
<li>静态分派：<ol>
<li>优先级:char&gt;int&gt;long&gt;Character&gt;Serializable&gt;Object&gt;char…</li>
<li>如果不存在char的，优先匹配int，以此类推</li>
<li>编译的时候就已经决定了这个调用的优先顺序</li>
</ol>
</li>
<li>动态分派：<ol>
<li>在编译器中，重写的方法被视作了一个方法</li>
<li>按照类型进行分派</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="方法的字节码调用"><a href="#方法的字节码调用" class="headerlink" title="方法的字节码调用"></a>方法的字节码调用</h2><ol>
<li>参PPT</li>
</ol>
<h1 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h1><ol>
<li>步骤如下：  <ol>
<li>首先加载一条链上的各个类</li>
<li>先进行静态初始化，优先初始化父类，之后初始化子类</li>
<li>将所有的成员变量先设置为0系的初值</li>
<li>开始调用父类的构造方法，一条链向上</li>
<li>将所有的成员变量按照字面顺序初始化</li>
<li>剩余的所有的部分的初始化</li>
</ol>
</li>
<li>考察构造顺序</li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/07/java_BigDecimal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Stormbroken">
      <meta itemprop="description" content="没有什么能够阻挡一直学习的心。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Stormbrokenの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/2019/10/07/java_BigDecimal/" class="post-title-link" itemprop="url">java学习笔记 之 BigDecimal</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-07 13:52:05 / 修改时间：14:00:01" itemprop="dateCreated datePublished" datetime="2019-10-07T13:52:05+08:00">2019-10-07</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

        

      
          <a id="more"></a>
<p><strong>java变量类型——BigDecimal</strong></p>
<ol>
<li>java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。</li>
<li>float和double只能用来做科学计算和工程计算，而在商业运算中我们要使用BigDecimal</li>
</ol>
<h1 id="获得BigDecimal类的对象"><a href="#获得BigDecimal类的对象" class="headerlink" title="获得BigDecimal类的对象"></a>获得BigDecimal类的对象</h1><ol>
<li>将BigDecimal转换存Double:<ul>
<li>推荐使用<code>new BigDecimal(num+&quot;&quot;)</code></li>
<li>尽量避免使用<code>new BigDecimal(num)</code>，因为这样会有比较多的无效位数。</li>
</ul>
</li>
<li>除此以外，我们可以通过写数字的值或者string来创建BigDecimal类型。<ul>
<li>尽量选择string因为其精度高</li>
</ul>
</li>
</ol>
<h1 id="BigDecimal类的运算"><a href="#BigDecimal类的运算" class="headerlink" title="BigDecimal类的运算"></a>BigDecimal类的运算</h1><ol>
<li>必须都是BigDecimal对象才能被使用。</li>
</ol>
<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><ol>
<li>add()函数</li>
</ol>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><ol>
<li>substract()函数</li>
</ol>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><ol>
<li>multiply()函数</li>
</ol>
<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ol>
<li>divide(BigDecimal,scale,舍入方式)函数<ul>
<li>在指定情况下，我们需要指定scale位数来确定精度。</li>
</ul>
</li>
</ol>
<h2 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h2><ol>
<li>abs()函数</li>
</ol>
<h2 id="带余除法"><a href="#带余除法" class="headerlink" title="带余除法"></a>带余除法</h2><ol>
<li><code>public BigDecimal[] divideAndRemainder(BigDecimal divisor)</code></li>
<li>接受一个BigDecimal对象作为参数，该参数即为除数，返回一个BigDecimal数组。<ul>
<li>数组中包含两个元素:第一个元素为两数相除的商，第二个元素是除数。</li>
</ul>
</li>
</ol>
<h1 id="其他的BigDecimal的API"><a href="#其他的BigDecimal的API" class="headerlink" title="其他的BigDecimal的API"></a>其他的BigDecimal的API</h1><ol>
<li><code>stripTrailingZeros()</code>将其格式化一个相等的，但去掉了末尾0的BigDecimal</li>
</ol>
<h1 id="BigDecimal舍入模式"><a href="#BigDecimal舍入模式" class="headerlink" title="BigDecimal舍入模式"></a>BigDecimal舍入模式</h1><ol>
<li>属于java.math.RoundingMode</li>
</ol>
<h2 id="ROUND-UP"><a href="#ROUND-UP" class="headerlink" title="ROUND_UP"></a>ROUND_UP</h2><ol>
<li>舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字。(始终对非零舍弃部分前面的数字加1)</li>
<li>这个舍入模式始终不会减少计算值的大小</li>
</ol>
<h2 id="ROUND-DOWN"><a href="#ROUND-DOWN" class="headerlink" title="ROUND_DOWN"></a>ROUND_DOWN</h2><ol>
<li>接近零的舍入模式。在对齐某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截断)。</li>
<li>这个舍入模式始终不会增加计算值的大小。</li>
</ol>
<h2 id="ROUND-CEILING"><a href="#ROUND-CEILING" class="headerlink" title="ROUND_CEILING"></a>ROUND_CEILING</h2><ol>
<li>接近正无穷大的舍入模式。如果为正，和ROUND_UP相同。若为负，则相反。</li>
<li>此舍入模式始终不会减少计算值。</li>
</ol>
<h2 id="ROUND-FLOOR"><a href="#ROUND-FLOOR" class="headerlink" title="ROUND_FLOOR"></a>ROUND_FLOOR</h2><ol>
<li>接近负无穷大的舍入模式。如果为正，则舍入行为和ROUND_DOWN相同。若为负，则和ROUND_UP相同。</li>
<li>此舍入模式始终不会增加计算值。</li>
</ol>
<h2 id="ROUNG-HALF-UP"><a href="#ROUNG-HALF-UP" class="headerlink" title="ROUNG_HALF_UP"></a>ROUNG_HALF_UP</h2><ol>
<li>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。</li>
<li>也就是我们学的四舍五入。</li>
</ol>
<h2 id="ROUND-HALF-DOWN"><a href="#ROUND-HALF-DOWN" class="headerlink" title="ROUND_HALF_DOWN"></a>ROUND_HALF_DOWN</h2><ol>
<li>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。<br>如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。</li>
</ol>
<h2 id="ROUND-HALF-EVEN"><a href="#ROUND-HALF-EVEN" class="headerlink" title="ROUND_HALF_EVEN"></a>ROUND_HALF_EVEN</h2><ol>
<li>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;</li>
<li>如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。</li>
<li>注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。</li>
<li>此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。如果前一位为奇数，则入位，否则舍去。以下例子为保留小数点1位，那么这种舍入方式下的结果。<ul>
<li>1.15&gt;1.2 1.25&gt;1.2</li>
</ul>
</li>
</ol>
<h2 id="ROUND-UNNESSARY"><a href="#ROUND-UNNESSARY" class="headerlink" title="ROUND_UNNESSARY"></a>ROUND_UNNESSARY</h2><ol>
<li>断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.cnblogs.com/jpfss/p/9987319.html" target="_blank" rel="noopener">星朝</a></li>
<li><a href="https://blog.csdn.net/bailu666666/article/details/79829902" target="_blank" rel="noopener">java大数类</a></li>
</ol>
<h1 id="转换为相应类型进行返回"><a href="#转换为相应类型进行返回" class="headerlink" title="转换为相应类型进行返回"></a>转换为相应类型进行返回</h1><ol>
<li>toString()将BigDecimal对象的数值转换成字符串。    </li>
<li>doubleValue()将BigDecimal对象中的值以双精度数返回。   </li>
<li>floatValue()将BigDecimal对象中的值以单精度数返回。   </li>
<li>longValue()将BigDecimal对象中的值以长整数返回。    </li>
<li>intValue()将BigDecimal对象中的值以整数返回。</li>
</ol>

        
      
    </div>

    
    
    
    <div>
      
    </div>
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Stormbroken</p>
  <div class="site-description" itemprop="description">没有什么能够阻挡一直学习的心。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-Stormbroken"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stormbroken</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.1"></script><script src="/js/motion.js?v=7.4.1"></script>
<script src="/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/js/next-boot.js?v=7.4.1"></script>



  





















  

  

  

</body>
</html>

<a href="https://github.com/stormbroken" class="" target="_blank" title="我的Github" aria-label="我的Github">
  <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
  </svg>
</a>

<!-- ??????? -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
