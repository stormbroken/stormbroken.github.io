<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stormbrokenの博客</title>
  
  <subtitle>留下生活学习的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-24T04:10:15.473Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Stormbroken</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GB2312</title>
    <link href="http://yoursite.com/2019/10/24/GB2312/"/>
    <id>http://yoursite.com/2019/10/24/GB2312/</id>
    <published>2019-10-24T04:07:30.088Z</published>
    <updated>2019-10-24T04:10:15.473Z</updated>
    
    <content type="html"><![CDATA[<p>GB2312编码</p><a id="more"></a><h1 id="1-什么是GB2312"><a href="#1-什么是GB2312" class="headerlink" title="1. 什么是GB2312"></a>1. 什么是GB2312</h1><ol><li>它是一种中文字符标准</li></ol><h1 id="2-GB2312和UTF-8、GBK之间的关系"><a href="#2-GB2312和UTF-8、GBK之间的关系" class="headerlink" title="2. GB2312和UTF-8、GBK之间的关系"></a>2. GB2312和UTF-8、GBK之间的关系</h1><ol><li>GBK是在国家标准GB2312基础上扩容兼容GB2312的标准。</li><li>三者之间的转换必须都通过Unicode编码才能相互转换</li></ol><h1 id="3-GB2312的汉字表示方法"><a href="#3-GB2312的汉字表示方法" class="headerlink" title="3. GB2312的汉字表示方法"></a>3. GB2312的汉字表示方法</h1><h2 id="3-1-分区表示"><a href="#3-1-分区表示" class="headerlink" title="3.1. 分区表示"></a>3.1. 分区表示</h2><ol><li>每个区含有94个汉字/符号。这种表示方式也称为区位码。<ul><li>01-09区为特殊符号</li><li>16-55区为一级汉字，按拼音排序</li><li>56-87区为二级汉字，按拼音/笔画排序</li><li>10-15以及88-94区则未有编码</li></ul></li></ol><h2 id="3-2-字节结构"><a href="#3-2-字节结构" class="headerlink" title="3.2. 字节结构"></a>3.2. 字节结构</h2><ol><li>采用EUC存储方法，以便兼容与ASCII。</li><li>每个汉字以及符号用两个字节来表示。第一个字节称为“高位字节”(区字节)，第二个字节称为“低位字节”(位字节)<ul><li>高位字节用了0xA1-0xF7</li><li>低位字节使用了0xA1-0xFE</li><li>占用的码位72*94=6768，其中空位为D7FA-D7FE</li></ul></li><li>区位码 = 区字节 + 位字节</li></ol><h1 id="4-EUC存储方式"><a href="#4-EUC存储方式" class="headerlink" title="4. EUC存储方式"></a>4. EUC存储方式</h1><ol><li>EUC全称Extended Unix Code，是一个使用8位编码来表示字符的方法。EUC最初是针对Unix系统，在1991年被标准化。</li><li>EUC定义了4个单独的码集。<ul><li>码集0 —— 7位的ASCII，编码为单字节</li><li>码集1,2,3 —— G1空间的值</li><li>码集1 —— 未修饰的字符，编码为1-3字节</li><li>码集2 —— 以0x8E(SS2)为第一字节，编码为至少2字节。</li><li>码集3 —— 以0x8F(SS3)为第一字节，编码为至少2字节。</li></ul></li></ol><h2 id="4-1-GB2312-EUC-CN"><a href="#4-1-GB2312-EUC-CN" class="headerlink" title="4.1. GB2312(EUC-CN)"></a>4.1. GB2312(EUC-CN)</h2><ol><li>EUC-CN是GB2312最常用的表示方法。</li><li>使用了码集0和码集1</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GB2312编码&lt;/p&gt;
    
    </summary>
    
    
      <category term="字符图片编码" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E5%9B%BE%E7%89%87%E7%BC%96%E7%A0%81/"/>
    
    
      <category term="字符图片编码" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E5%9B%BE%E7%89%87%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>图片编码</title>
    <link href="http://yoursite.com/2019/10/24/%E5%9B%BE%E7%89%87%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2019/10/24/图片编码/</id>
    <published>2019-10-24T04:04:26.114Z</published>
    <updated>2019-10-26T15:41:48.225Z</updated>
    
    <content type="html"><![CDATA[<p>图片编码</p><a id="more"></a><h1 id="1-图像的基本结构"><a href="#1-图像的基本结构" class="headerlink" title="1. 图像的基本结构"></a>1. 图像的基本结构</h1><ol><li>在计算计算机中，图像是由一个个像素点(也称颜色点)组成。</li><li>颜色最简单的显示方式:RGB或RGBA表示<ul><li>其中R通道是指蓝颜色通道</li><li>其中G通道是指绿颜色通道</li><li>其中B通道是指蓝颜色通道</li><li>其中A通道是指这个图像可以有透明效果</li><li>三个分量一般是用一个字节(8位)来表示</li></ul></li></ol><h2 id="1-1-图片通道编码的分离和合并"><a href="#1-1-图片通道编码的分离和合并" class="headerlink" title="1.1. 图片通道编码的分离和合并"></a>1.1. 图片通道编码的分离和合并</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image <span class="comment"># 导入</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(situation,ob1,ob2,ob3)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(situation == <span class="string">"0"</span>):</span><br><span class="line">        <span class="keyword">return</span> ob1</span><br><span class="line">    <span class="keyword">elif</span>(situation == <span class="string">"1"</span>):</span><br><span class="line">        <span class="keyword">return</span> ob2</span><br><span class="line">    <span class="keyword">elif</span>(situation == <span class="string">"2"</span>):</span><br><span class="line">        <span class="keyword">return</span> ob3</span><br><span class="line">    print(<span class="string">"Wrong!"</span>)</span><br><span class="line">    <span class="keyword">return</span> ob1</span><br><span class="line"><span class="comment"># 导入的数据图都是RGBA，暂未做适配</span></span><br><span class="line">im1 = Image.open(<span class="string">'test.png'</span>)</span><br><span class="line">im2 = Image.open(<span class="string">'test1.png'</span>)</span><br><span class="line">im3 = Image.open(<span class="string">'test2.png'</span>)</span><br><span class="line">im1 = im1.resize((<span class="number">1500</span>,<span class="number">1000</span>))</span><br><span class="line">im2 = im2.resize((<span class="number">1500</span>,<span class="number">1000</span>))</span><br><span class="line">im3 = im3.resize((<span class="number">1500</span>,<span class="number">1000</span>))</span><br><span class="line">r0, g0, b0, c0 = im1.split()</span><br><span class="line">r1, g1, b1, c1 = im2.split()</span><br><span class="line">r2, g2, b2, c2 = im3.split()</span><br><span class="line">temp_1 = str(random.randint(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">temp_2 = str(random.randint(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">temp_3 = str(random.randint(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">temp_4 = str(random.randint(<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">print(temp_1 + <span class="string">" | "</span>+ temp_2 + <span class="string">" | "</span>+ temp_3 +<span class="string">" | "</span>+ temp_4)</span><br><span class="line">result = Image.merge(<span class="string">"RGBA"</span>, [getRandom(temp_1,r0,r1,r2),</span><br><span class="line">                              getRandom(temp_2,g0,g1,g2),</span><br><span class="line">                              getRandom(temp_3,b0,b1,b2),</span><br><span class="line">                             getRandom(temp_4, c0, c1, c2)])</span><br><span class="line">result.save(<span class="string">"result.png"</span>)</span><br></pre></td></tr></table></figure><h1 id="2-像素的32位对齐"><a href="#2-像素的32位对齐" class="headerlink" title="2. 像素的32位对齐"></a>2. 像素的32位对齐</h1><ol><li>如果是RGB24位图，会存在一个32位对齐的问题<ul><li>在x86体系下，cpu一次性处理32倍数的数据会更快。</li></ul></li><li>24位图，宽度不是4的倍数，其行字结束将不是32整数倍。这时候我们可以采取在行尾添加冗余数据的方式，使其字节数为32的倍数。</li><li>Eg.图像像素宽为5像素，不做32位对齐时，行尾数为120，相对于最近向上取整的32的倍数是128，也就是我们只要添加一字节的冗余数据即可。</li></ol><h1 id="3-不同图像格式存储的不同的特点"><a href="#3-不同图像格式存储的不同的特点" class="headerlink" title="3. 不同图像格式存储的不同的特点"></a>3. 不同图像格式存储的不同的特点</h1><ol><li>为什么要用一定的格式进行压缩？<ul><li>因为如果按照图像原始格式直接存储到文件中将会非常大。</li></ul></li></ol><h2 id="3-1-各种文件存储格式"><a href="#3-1-各种文件存储格式" class="headerlink" title="3.1. 各种文件存储格式"></a>3.1. 各种文件存储格式</h2><h3 id="3-1-1-zip-amp-rar通用算法"><a href="#3-1-1-zip-amp-rar通用算法" class="headerlink" title="3.1.1. zip &amp; rar通用算法"></a>3.1.1. zip &amp; rar通用算法</h3><ol><li>我们如果选用zip或者rar之类的通用算法来压缩像素数据，得到的压缩比例通常不会太高,大概也是因为它是一个通用算法的缘故。</li></ol><h3 id="3-1-2-jpg-amp-png格式"><a href="#3-1-2-jpg-amp-png格式" class="headerlink" title="3.1.2. jpg &amp; png格式"></a>3.1.2. jpg &amp; png格式</h3><ol><li>jpg和png都是针对图形的不同图像压缩算法</li></ol><h3 id="3-1-3-jpeg格式"><a href="#3-1-3-jpeg格式" class="headerlink" title="3.1.3. jpeg格式"></a>3.1.3. jpeg格式</h3><ol><li>jpeg格式是有损压缩格式，将像素信息用jpeg保存成文件再读取出来，其中某些像素值会有所变化<ul><li>保存质量参数:决定图片保真的情况。</li></ul></li></ol><h3 id="3-1-4-BMP格式"><a href="#3-1-4-BMP格式" class="headerlink" title="3.1.4. BMP格式"></a>3.1.4. BMP格式</h3><ol><li>BMP格式没有压缩过像素格式，存储在文件中时先有文件头，再图像头，后面是像素数据，上下颠倒储存。</li><li>bmp格式也可以进行压缩</li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>bmp有多种格式可以选择：<ol><li>单色:一个像素只占一位，存储黑白信息。</li><li>16色位图:一个像素4位</li><li>256色位图:一个像素8位。</li></ol></li></ol><h1 id="4-png格式"><a href="#4-png格式" class="headerlink" title="4. png格式"></a>4. png格式</h1><ol><li>是一种无损压缩的位图片形格式，PNG使用从LZ777派生的无损数据压缩算法，一般应用于JAVA程序，压缩比高，生成文件体积小。</li></ol><h2 id="4-1-压缩算法"><a href="#4-1-压缩算法" class="headerlink" title="4.1. 压缩算法"></a>4.1. 压缩算法</h2><ol><li>大概是行程编码算法</li><li>png可以有透明效果</li><li>png比较适合矢量图、几何图</li></ol><h2 id="4-2-数据块结构"><a href="#4-2-数据块结构" class="headerlink" title="4.2. 数据块结构"></a>4.2. 数据块结构</h2><ol><li>PNG图像格式文件(或者成为数据流)由一个8字节的PNG文件署名域(PNG file signature)和按照特定结构组织的三个以上的数据块(chunk)组成。</li></ol><h3 id="4-2-1-不同的数据块类型"><a href="#4-2-1-不同的数据块类型" class="headerlink" title="4.2.1. 不同的数据块类型"></a>4.2.1. 不同的数据块类型</h3><ol><li>关键数据块(ctritical chunk),这是必需的数据块。<ul><li>定义了4个标准数据块，每个PNG文件都必须包含它们，PNG读写软件也必须支持这些数据块。</li></ul></li><li>辅助数据块(ancillary chunks),这是可选的数据块。</li></ol><h3 id="4-2-2-标准数据块的格式"><a href="#4-2-2-标准数据块的格式" class="headerlink" title="4.2.2. 标准数据块的格式"></a>4.2.2. 标准数据块的格式</h3><ol><li>每个数据块都由四个域组成</li><li>长度:<ul><li>一个4字节的无符号整数，给出数据块的数据字段的长度(以字节计)。长度只计算数据域。为了兼容一些不支持无符号的语言，所以长度被限制在(2<sup>31</sup>-1)字节且不能<strong>达到</strong></li></ul></li><li>数据块类型码:<ul><li>一个4字节的块类型代码。为了便于描述和检查PNG文件，类型代码仅限于大写和小写的ASCII字母。然而编码器和解码器必须把代码作为固定的二进制值而非字符串来处理。</li></ul></li><li>数据域:<ul><li>数据块的数据域，存储按照数据块类型码指定的数据。该字段可以是长度为0</li></ul></li><li>循环冗余检测<ul><li>一个4字节的CRC(循环冗余校验)计算，在所述块的前面的字节，包括该块类型的代码和数据块的数据字段，但是不包括长度字段，CRC始终存在。</li></ul></li></ol><h2 id="4-3-python处理图片"><a href="#4-3-python处理图片" class="headerlink" title="4.3. python处理图片"></a>4.3. python处理图片</h2><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><ol><li><a href="https://blog.csdn.net/woniuye/article/details/89218461" target="_blank" rel="noopener">各种图片编码格式详解（bmp,jpg,png）</a></li><li>百度百科</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图片编码&lt;/p&gt;
    
    </summary>
    
    
      <category term="字符图片编码" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E5%9B%BE%E7%89%87%E7%BC%96%E7%A0%81/"/>
    
    
      <category term="字符图片编码" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E5%9B%BE%E7%89%87%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2019/10/14/modern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/10/14/modern/工厂模式/</id>
    <published>2019-10-14T01:31:07.106Z</published>
    <updated>2019-10-14T09:50:53.468Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看工厂模式的相关信息</p><a id="more"></a><h1 id="引入部分"><a href="#引入部分" class="headerlink" title="引入部分"></a>引入部分</h1><h2 id="关于new关键词的思考"><a href="#关于new关键词的思考" class="headerlink" title="关于new关键词的思考"></a>关于new关键词的思考</h2><ol><li>更多的对象具体类的创建应当在运行时确定而不是在编译的时候确定。</li><li>简单的if语句进行条件判断实例化对象，会降低系统的可维护性。</li><li>我们应当针对接口编程，保证尽量对修改关闭，想用具体类型来扩展代码必须重新打开它。</li></ol><h2 id="封装创建对象的代码"><a href="#封装创建对象的代码" class="headerlink" title="封装创建对象的代码"></a>封装创建对象的代码</h2><ol><li>也就是将创建类型的代码隔离到外部。</li><li>我们将这个新的对象叫做“工厂”。</li></ol><ol><li><p>工厂是处理对象的细节。</p></li><li><p>保证了各部分之间的耦合程度，增强了原系统的复用性，保证了整个系统的可修改性。</p></li><li><p>有一种思路是使用静态方法来定义一个简单的工厂，但是这就不能通过继承来改变创建方法的行为。</p></li><li><p>保证主体对象持有一个factory，并且需要在构造方法中传入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>&#123;</span><br><span class="line">    Factory factory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(Factory factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造一个持有一个factory的store</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上是简单工厂。</p></li></ol><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><ol><li>工厂方法用来处理对象的创建，将这样的行为封装在子类中。如此，客户程序中关于超类的代码和子类对象创建代码解耦成功。</li><li>实例:<code>abstract Product factoryMethod(String type)</code></li></ol><h2 id="允许子类做决定"><a href="#允许子类做决定" class="headerlink" title="允许子类做决定"></a>允许子类做决定</h2><ol><li>在超类PizzaStore中实现orderPizza()而设立createPizza()的接口，将制作过程下放到相应的子类</li><li>解耦:一个方法知道要做什么，但是不知道具体到底做了什么。具体做什么由具体调用的子类来决定</li></ol><h2 id="工厂模式实例解析"><a href="#工厂模式实例解析" class="headerlink" title="工厂模式实例解析"></a>工厂模式实例解析</h2><ol><li>首先分析创建了相应的PizzaStore的超类，之后实现这个类，调用其中的工厂方法来完成产品生产</li><li>同样要实例化相应的产品类</li></ol><h1 id="认识工厂方法模式"><a href="#认识工厂方法模式" class="headerlink" title="认识工厂方法模式"></a>认识工厂方法模式</h1><ol><li>所有工厂模式都用来封装对象的创建。</li><li>工厂模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</li><li>组成元素是平行的类层级。</li><li>将各部分</li></ol><h2 id="组成元素一-创建者类"><a href="#组成元素一-创建者类" class="headerlink" title="组成元素一:创建者类"></a>组成元素一:创建者类</h2><ol><li>创建一个抽象类，通过实例化其中的一些方法来完成相应对象的实例化。</li><li>其抽象产品由子类制造。</li></ol><h2 id="组成元素二-产品类"><a href="#组成元素二-产品类" class="headerlink" title="组成元素二:产品类"></a>组成元素二:产品类</h2><ol><li>创建了抽象的产品对象</li><li>然后通过装配来完成具体产品对象的创建。</li></ol><h1 id="定义工厂方法模式"><a href="#定义工厂方法模式" class="headerlink" title="定义工厂方法模式"></a>定义工厂方法模式</h1><ol><li><strong>工厂方法模式</strong>定义为一个创建对象的接口，但由子类决定实例化的类是哪一个，工厂方法让类把实例化推迟到子类。<ul><li>由子类决定</li><li>将实现和使用相分离，即“解耦”</li></ul></li><li>注:<ol><li>工厂方法和创建者可以不总是抽象的。</li><li>可以通过java的enum避免部分运行时编译错误。</li></ol></li><li>如果你想要把客户代码从需要实例化的具体类中解耦。</li></ol><h1 id="设计原则-依赖倒置原则"><a href="#设计原则-依赖倒置原则" class="headerlink" title="设计原则:依赖倒置原则"></a>设计原则:依赖倒置原则</h1><ol><li>依赖倒置原则通则:要依赖抽象，不要依赖具体类。</li><li>进一步解释:不能让高层组件依赖于低层组件，而且不管高层或低层组件，“两者”都应该依赖于抽象。</li><li>工厂模式并不是依赖倒置原则的唯一技巧，但是是最有威力的技巧之一。</li></ol><h2 id="依赖倒置原则带来的思维变化"><a href="#依赖倒置原则带来的思维变化" class="headerlink" title="依赖倒置原则带来的思维变化"></a>依赖倒置原则带来的思维变化</h2><ol><li>以pizza为例，正常的思维是思考具体有什么Pizza，而现在的思维应该是我们想象有Pizza，在回头思考如何设计Pizza店(工厂)。</li></ol><h2 id="几个关于依赖倒置原则的指导方针"><a href="#几个关于依赖倒置原则的指导方针" class="headerlink" title="几个关于依赖倒置原则的指导方针"></a>几个关于依赖倒置原则的指导方针</h2><ol><li>变量不可以持有具体类的引用。</li><li>不要让派生自具体类。</li><li>不要覆盖基类中已实现的方法。</li><li>其他注意要点:<ol><li>应当尽量达到这个原则，而不是随时都要遵守这个原则。</li></ol></li></ol><h1 id="关于实现接口的注释"><a href="#关于实现接口的注释" class="headerlink" title="关于实现接口的注释"></a>关于实现接口的注释</h1><h2 id="在设计模式中，所谓的”实现一个接口”并“不一定”表示写一个类，利用implements关键词来实现一个接口。“实现一个接口”泛指“实现某个超类型”"><a href="#在设计模式中，所谓的”实现一个接口”并“不一定”表示写一个类，利用implements关键词来实现一个接口。“实现一个接口”泛指“实现某个超类型”" class="headerlink" title="在设计模式中，所谓的”实现一个接口”并“不一定”表示写一个类，利用implements关键词来实现一个接口。“实现一个接口”泛指“实现某个超类型”"></a>在设计模式中，所谓的”实现一个接口”并“不一定”表示写一个类，利用implements关键词来实现一个接口。“实现一个接口”泛指“实现某个超类型”</h2><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="引入-原料工厂"><a href="#引入-原料工厂" class="headerlink" title="引入:原料工厂"></a>引入:原料工厂</h2><ol><li>有一些原料需要保证一致性，可以封装到原料工厂中去。</li><li>原料工厂不关心具体产品工厂的操作，而更多的关注相应原料的具体实现。</li><li>也就是制造出一个抽象原料工厂，定义相应的结构，在相应具体工厂中实现。<ul><li>首先，使用prepare()方法，准备好相应的原料。</li></ul></li></ol><h2 id="抽象工厂模式-另一个工厂模式"><a href="#抽象工厂模式-另一个工厂模式" class="headerlink" title="抽象工厂模式(另一个工厂模式)"></a>抽象工厂模式(另一个工厂模式)</h2><ol><li>正式定义:提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li><li>抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品。</li></ol><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2019/10/14/modern/工厂模式/fty-1.png" alt></p><h2 id="类图细节"><a href="#类图细节" class="headerlink" title="类图细节"></a>类图细节</h2><p><img src="/2019/10/14/modern/工厂模式/fty-2.png" alt></p><ol start="3"><li>工厂方法经常是抽象工厂的方法。</li><li>当需要创建产品家族和想让制造的相关产品集合起来时，可以选择抽象工厂模式。</li></ol><h2 id="工厂方法和抽象工厂比较"><a href="#工厂方法和抽象工厂比较" class="headerlink" title="工厂方法和抽象工厂比较"></a>工厂方法和抽象工厂比较</h2><p><img src="/2019/10/14/modern/工厂模式/fty-3.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看工厂模式的相关信息&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 部分实体类</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/10/07/java/java_实体类/</id>
    <published>2019-10-07T05:52:05.694Z</published>
    <updated>2019-10-07T07:55:24.032Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><h1 id="字符串相关类"><a href="#字符串相关类" class="headerlink" title="字符串相关类"></a>字符串相关类</h1><ol><li>字符串是不可变类，本质上是按照字符数组存储的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello"</span>;</span><br><span class="line">String b = <span class="string">"hello"</span>;</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"hi"</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">"hi"</span>);</span><br><span class="line"><span class="keyword">char</span>[] e = &#123;<span class="string">'h'</span>,<span class="string">'i'</span>&#125;;</span><br><span class="line">a==b;<span class="comment">//true</span></span><br><span class="line">c==d;<span class="comment">//false</span></span><br><span class="line">a==e;<span class="comment">//编译错误</span></span><br><span class="line">a.equals(e);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h2><ol><li>String类对象保存不可修改的Unicode字符序列</li><li>String类的下述方法能创建并返回一个新的String对象</li><li>功能性方法：endsWith、startsWith、indexOf、lastIndexOf、equals、equalsIgnoreCase、compareTo</li><li>其他方法:charAt、length、replace()</li></ol><h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><ol><li>StringBuffer类：<ol><li>构造方法：<ol><li><code>StringBuffer()</code>:创建一个字符序列为空的StringBuffer对象</li><li><code>StringBuffer(String str)</code>:创建一个把与String对象str相同的字符序列</li></ol></li><li>其他方法：<ol><li>append()方法：想StringBuffer对象添加字符序列</li><li>delete(int start,int end):删除从start开始到end-1为止的一端字符序列，返回对象引用</li><li>deleteCharAt(int index):删除位于序列指定位置上的char</li><li>insert(int offset,String str):可以在指定位置上插入字符序列等</li><li>insert(int offest,double d):插入一个浮点数，提供自动转化</li><li>setCharAt(int index，char ch):在指定位置上插入指定字符</li></ol></li></ol></li><li>区分String和StringBuffer和StringBuilder：<ol><li>String：不可变字符序列</li><li>StringBuffer：可变字符序列，并且线程安全，但是效率低</li><li>StringBuilder：可变字符序列，线程不安全，但是效率高</li></ol></li></ol><h1 id="时间相关的处理类"><a href="#时间相关的处理类" class="headerlink" title="时间相关的处理类"></a>时间相关的处理类</h1><h2 id="Date时间类"><a href="#Date时间类" class="headerlink" title="Date时间类"></a>Date时间类</h2><ol><li>来源：java.util.Date</li><li>表示一个特定的瞬间，精确到毫秒</li></ol><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li><code>Date()</code>:分配一个Date对象，并初始化此对象为当前的日期和时间精确到毫秒</li><li><code>Date(Long date)</code>:分配Date对象并初始化此对象，以表示从标准基准时间，即1970年1月1日00:00:00 GMT以指定毫秒数</li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table><thead><tr><th>返回值</th><th>函数名</th><th>函数意义</th></tr></thead><tbody><tr><td>Boolean</td><td>after(Date when)</td><td>测试该日期是否在指定日期以后</td></tr><tr><td>Boolean</td><td>before(Date when)</td><td>测试该日期是否在指定日期之前</td></tr><tr><td>Boolean</td><td>equals(Date when)</td><td>比较两个日期的相等性，重写的方法</td></tr><tr><td>Long</td><td>getTime()</td><td>返回自1970年1月1日00:00:00 GMT以来的</td></tr><tr><td>String</td><td>toString()</td><td>把此Date对象转换为各种形式的String</td></tr></tbody></table><h2 id="DateFormat类和SimpleDateFormat类"><a href="#DateFormat类和SimpleDateFormat类" class="headerlink" title="DateFormat类和SimpleDateFormat类"></a>DateFormat类和SimpleDateFormat类</h2><ol><li><p>构造:<code>SimpleDateFormat a = new SimpleDateFormat(&quot;YYYY-MM-dd&quot;)</code></p></li><li><p>按照构造中的格式转化生成相应Date对象：<code>Date date = a.parse(&quot;2019-6-21&quot;)</code></p></li><li><p>具体的格式化字符介绍</p><table><thead><tr><th>标识符</th><th>内涵</th></tr></thead><tbody><tr><td>G</td><td>年代标志符</td></tr><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>h</td><td>时，12进制，1-12</td></tr><tr><td>H</td><td>时，24进制，0-23</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr><tr><td>S</td><td>毫秒</td></tr><tr><td>E</td><td>星期</td></tr><tr><td>D</td><td>一年中的第几天</td></tr><tr><td>F</td><td>一月中第几个星期几</td></tr><tr><td>w</td><td>一年中第几个星期</td></tr><tr><td>W</td><td>一月中的第几个星期</td></tr><tr><td>a</td><td>上午/下午 标记符</td></tr><tr><td>k</td><td>时，一天中(1-24)</td></tr><tr><td>K</td><td>时，在上午或下午(0-11)</td></tr><tr><td>z</td><td>时区</td></tr><tr><td>2. 使用的语句：<code>SimpleDateFormat a = new SimpleDateFormat(&quot;yyyy&quot;)</code></td><td></td></tr><tr><td>3. 转化成为字符串：<code>a.format(now)</code></td><td></td></tr></tbody></table></li></ol><h2 id="Calendar日历类"><a href="#Calendar日历类" class="headerlink" title="Calendar日历类"></a>Calendar日历类</h2><ol><li>他是一个抽象类，定义了一些特定的日历字段之间的转换用的方法</li><li>注意月份的表示中：一月是0</li></ol><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><ol><li>来源:java.lang.Math</li><li>相应的方法：<ul><li>abs:绝对值</li><li>acos,asin,atan,cos,sin,tan：各种三角函数</li><li>sqrt：平方根</li><li>pow(double a,double b)：a的b次幂</li><li>log自然对数</li><li>exp e为底指数</li><li>max(double a,double b)</li><li>min(double a,double b)</li><li>random()：返回0.0到1.0的随机数</li><li>long round(double a)：double类型的数据a转化为long类型</li><li>toDegrees(double angrad)：弧度-&gt;角度</li><li>toRadians(double angdeg)：角度-&gt;弧度</li></ul></li></ol><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><ol><li>来源：java.io.File类</li><li>常见的构造方法：<code>public File(String pathname)</code><ul><li>构造方法参数可以为String、File、URL</li></ul></li><li>方法：<ul><li>public boolean canRead()</li><li>public boolean canWrite()</li><li>public boolean exists()     </li><li>public boolean isDirectory()</li><li>public boolean isFile()     </li><li>public boolean isHidden()</li><li>public long lastModified() </li><li>public long length()</li><li>public String getName()   </li><li>public String getPath()</li><li>public String getAbsolutePath()</li><li>public boolean delete()</li><li>public boolean mkdir():创建新的文件夹</li></ul></li><li>equals()方法在这个类中被重写，只有两个对象的内容和类型一致时返回</li></ol><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><ol><li>只能够取特定值中的一个</li><li>使用enum关键字</li><li>所有的枚举类型都隐形地继承自java.lang.Enum。而每个被枚举的变量都被默认为public static final的</li><li>建议使用一组常量的时候，使用枚举类型</li><li>尽量避免使用枚举的高级特性</li></ol><h1 id="Applet类"><a href="#Applet类" class="headerlink" title="Applet类"></a>Applet类</h1><ol><li>是一个采用java编程语言编写的小应用程序</li><li>可以读取客户端部分系统变量</li><li>不可以读取客户端文件</li><li>不可以在客户端主机上创建新文件</li><li>不可以在客户端装载程序库</li><li><code>&lt;applet code=TestApplet.class width=100 height=100&gt;&lt;/applet&gt;</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 OO</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/07/java/java_面向对象编程/</id>
    <published>2019-10-07T05:52:05.694Z</published>
    <updated>2019-10-07T07:55:20.415Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>面向对象编程(职责&amp;协作)</strong></p><ol><li>对象定义：是类的实例，有具体的属性，可以执行具体的行为。    <h1 id="职责-功能"><a href="#职责-功能" class="headerlink" title="职责(功能)"></a>职责(功能)</h1></li><li>职责：可以理解为对象的功能<ul><li>通过对需求的分析，寻找系统所需的功能，然后通过设计确定每个类的职责。</li></ul><ol><li>单一职责原则：(SRP):就一个类而言，应该仅有一个引起它变化的原因。</li><li>需求：是系统必须具有的特征，或者是客户可接受的、系统必须满足的约束，即我们要解决的“问题”。</li><li>场景：一种人们将做什么的陈述性描述，以及人们试图利用计算机系统和应用程序经验的陈述性描述。描述一个用户和系统之间交互的一系列步骤。场景是需求获取中的一种重要手段。一个场景是来自单一参与者的、具体的、关注点集中的系统单一特征的非形式化描述。</li></ol></li><li>数据职责和行为职责在一起，将职责合理分配</li><li>数据和行为之间存在于一定的关系</li><li>类和对象：<ol><li>类-职责的抽象</li><li>对象-职责的实现</li><li>类和对象是抽象与具体关系</li></ol></li><li>给对象分配责任的策略：<ol><li>分配所有重要方面</li><li>寻找需要执行的动作以及需要为何和生成的信息</li></ol></li><li><strong>数据职责是方法要用到的数据</strong></li><li>行为职责</li></ol><h1 id="世界观的变化"><a href="#世界观的变化" class="headerlink" title="世界观的变化"></a>世界观的变化</h1><ol><li>想法的变化：从原来函数之间的调用到现在的有职责的对象之间的交互</li><li>视角的变化：<ol><li>行为视角：结构化方法</li><li>数据视角：数据为中心方法</li><li>职责方法：面向对象方法</li></ol></li><li>在这种思路下，我们使用类来描述对象，使用类的方法来定义他们的行为</li></ol><h1 id="对象-职责的实现"><a href="#对象-职责的实现" class="headerlink" title="对象(职责的实现)"></a>对象(职责的实现)</h1><ol><li>对象是什么：<ol><li>定义：<ol><li>是客观世界问题空间中的某个具体的事物</li><li>是软件系统解空间中的基本元素</li></ol></li><li>对象的特征：<ol><li>每个对象都保存着描述当前特征的信息</li><li>对象状态的改变必须通过调用方法来实现</li><li>每个对象都有唯一的身份，边坡是永远不同，状态也常常不同</li></ol></li></ol></li><li>对象的初始化:<ol><li>在方法甚至是构造方法之前初始化</li><li>优先初始化静态变量，静态变量按照文字顺序初始化,例子见pdf</li></ol></li><li>对象定义：是类的实例，有具体的属性，可以执行具体的行为。  <h1 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h1></li><li>CRC卡  <a href="https://baike.baidu.com/item/CRC卡/5702018?fr=aladdin" target="_blank" rel="noopener">详见</a></li><li>类图</li><li>UMC：统一化建模语言</li><li>用例分析</li></ol><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ol><li>封装三原则：<ol><li>数据和行为放置在一块（在一起）</li><li>使用职责驱动型设计来决定如何确定一个类中的数据和行为</li><li>职责应当具有完备性</li></ol></li><li>是防御性编程的范例之一</li><li>封装的作用：<ol><li>隐藏类的实现细节，将类对外提供服务的接口和内部的具体实现进行分离，有助于在不影响对类使用的情况下修改类内部的实现</li><li>控制对成员变量的访问（可以在对成员变量的访问中加入数据检查和控制逻辑，限制对成员变量不合理的操作）</li></ol></li></ol><h2 id="类的职责和封装"><a href="#类的职责和封装" class="headerlink" title="类的职责和封装"></a>类的职责和封装</h2><ol><li>责任是指对象持有、维护特定数据并基于该数据进行操作的能力。</li><li>面向对象三要素：<ol><li>封装</li><li>继承</li><li>多态<h3 id="数据职责："><a href="#数据职责：" class="headerlink" title="数据职责："></a>数据职责：</h3><ul><li>表征对象的本质特征</li><li>行为（计算）所需要的数据<h3 id="行为职责"><a href="#行为职责" class="headerlink" title="行为职责:"></a>行为职责:</h3></li><li>表征对象的本质行为</li><li>拥有数据所应该体现的行为</li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 类</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/10/07/java/java_类/</id>
    <published>2019-10-07T05:52:05.694Z</published>
    <updated>2019-10-07T07:55:18.108Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ol><li>类的定义：是描述相同事物的集合，以概要的方式描述了相同事物集合中的所有元素，但却允许类中的每一个实体元素可以在非本质特征上变化</li><li>另一种定义：面向对象程序设计中最基本的概念，定义了一个事物的抽象特征，定义了事物的属性和对属性的操作（行为）。是一种抽象数据类型，即某类数据结构和其所具有行为的集合。<br><code>class</code>关键词。</li></ol><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><ol><li>类是对某个对象的定义</li><li>类包含相关对象的动作方式的信息</li><li>引用类的代码运行时，类的新实例对象就在内存中创建了</li><li>类应当有单一职责</li></ol><h2 id="创建类的原因"><a href="#创建类的原因" class="headerlink" title="创建类的原因"></a>创建类的原因</h2><ol><li>对现实世界中对象的建模</li><li>对抽象对象建模</li><li>降低复杂度</li><li>隔离复杂度</li><li>隐藏实现细节</li><li>限制变化影响的范围</li><li>创建中心控制点</li></ol><h2 id="类创建在堆上，类的成员"><a href="#类创建在堆上，类的成员" class="headerlink" title="类创建在堆上，类的成员:"></a>类创建在堆上，类的成员:</h2><ul><li>成员变量</li><li>成员方法</li></ul><h2 id="使用的功能性关键字"><a href="#使用的功能性关键字" class="headerlink" title="使用的功能性关键字"></a>使用的功能性关键字</h2><table><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td>返回值</td><td>返回一个值</td></tr><tr><td><code>return</code></td><td>提供返回值</td></tr><tr><td><code>extends</code></td><td>表示继承关系</td></tr><tr><td><code>new</code></td><td>用于新建</td></tr><tr><td><code>.</code></td><td>用来引用访问类内部成员</td></tr></tbody></table><h2 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h2><p>1.java的对象不具备和基本数据类型相同的生命周期。<br>2.java的对象在解除引用后需要考虑如何释放内存。  </p><h2 id="外部类的调用"><a href="#外部类的调用" class="headerlink" title="外部类的调用"></a>外部类的调用</h2><p>1.关键字：<code>import</code><br>2.更加常见的是同时导入一个类的所有方法。 </p><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><ol><li>方法名称和类名相同，参数不同，没有返回值</li><li>构造方法用于初始化一个类</li></ol><h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><ol><li>不可变字符串</li><li>java对于字符串的特殊处理：<ol><li>两种定义方式：<ul><li><code>String name = &quot;Tom&quot;</code>这样子不会新建内存</li><li><code>String name = new String(&quot;Tom&quot;)</code></li></ul></li><li>你在赋值时<code>name = &quot;Bob&quot;</code>,虚拟机不改变原来的对象，生成一个新的String对象，让name指向他，之后被解引用的会被回收。</li><li>使用<code>+</code>来生成字符串是一个非常浪费时间的操作<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3></li></ol></li><li>StringBuffer:支持多线程<ol><li>创建一个新的对象<code>StringBuffer sb = new StringBuffer(string.length*times//可选)</code></li><li>添加方法<code>.append()</code></li></ol></li><li>StringBuilder:不支持多线程<ol><li>创建一个新对象<code>StringBuilder name = new StringBuilder()</code></li><li>添加方法<code>.append()</code></li></ol></li></ol><h3 id="String-intern-方法"><a href="#String-intern-方法" class="headerlink" title="String.intern()方法"></a>String.intern()方法</h3><h3 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h3><ol><li><a href="https://blog.csdn.net/soft_zzti/article/details/79811923" target="_blank" rel="noopener">统一建模语言（UML)</a><br>name + instance variables + methods <blockquote><p>UML：  </p></blockquote><ol><li>分为四层，使用抽象概念（接口和继承）</li><li>可以在毕业设计中使用</li></ol></li><li>空心三角和实心直线表示继承</li><li>虚线表示抽象</li></ol><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><ol><li>关键字<code>abstract</code></li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol><li>有一些类不应该实例化</li><li>抽象类本身没有用，除非他被继承，有了子类。抽象类的子类可以实例化。</li><li>非抽象类中不可以有抽象方法</li><li>抽象类中可以有非抽象方法(非抽象方法表示已经被实现了)</li></ol><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ol><li>抽象方法的存在就是为了多态</li><li>具体的类必须实现所有的抽象方法</li><li>实现抽象方法就像子类覆盖父类方法一样</li></ol><h3 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h3><ol><li>类的初始化的步骤<ol><li>加载：由类加载器执行，查找字节码，并创建一个Class对象</li><li>链接：验证字节码，为静态域分配空间(只是分配，并不初始话该存储空间)，解析该类创建所需要的对其他类的应用</li><li>初始化：首先执行静态初始化块static，初始化静态变量，执行静态方法(如构造方法)<ul><li>先加载直到加载到本身的父类</li><li>然后进行逐一的静态初始化</li><li>对于所有变量进行初始化</li><li>调用父类构造函数</li><li>局部变量按照字面顺序被初始化</li><li>剩下的部分的构造函数的运行</li></ul></li></ol></li><li>可能对了执行初始化的操作:<ol><li>创建一个java类的实例对象</li><li>调用了一个java类的静态方法</li><li>为类或接口中的静态域赋值</li><li>访问类或接口中声明的静态域，并且该域的值不是常值变量</li><li>在一个顶层的java类中执行assert语句</li><li>调用Class类和反射API中进行反射操作</li></ol></li><li>注意:当访问一个java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化</li></ol><h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><ol><li>所有变量先初始化，优先于构造方法</li><li>先初始化静态变量，然后是非静态的</li><li>静态变量按照字面顺序进行初始化<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2></li><li>private:仅可以由包含该成员变量或者成员方法的类访问，用于防止对象的成员变量被非法修改或者某些仅供对象自身使用的方法。</li><li>public：可以被所有类访问，用于对外提供的服务</li><li>protected：对于自己的子类是可见的</li><li>默认权限：可以被同一个包中的其他类访问。同一个包中的类名不可重复。所有没有显示指定所属包的类都位于同一个包中。</li></ol><h1 id="基本数据类型的包装类"><a href="#基本数据类型的包装类" class="headerlink" title="基本数据类型的包装类"></a>基本数据类型的包装类</h1><ol><li>我们在实际使用中经常需要将基本数据转化成对象，便于操作。</li><li>为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型相应的类统称为包装类</li><li>包装类</li></ol><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>1. java中每个基本数据类型都有一个对应的封装类</td><td></td></tr><tr><td>2. 封装类包含的值可以通过equals()进行比较</td><td></td></tr><tr><td>3. 封装类包含的值不可以通过value()进行比较</td><td></td></tr><tr><td>4. 封装类除了Character类外，都可以作为构造方法的实参创建实例</td><td></td></tr></tbody></table><h2 id="包装类的用途"><a href="#包装类的用途" class="headerlink" title="包装类的用途"></a>包装类的用途</h2><ol><li>包装类包含每种数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</li><li>提供了基本类型之间的转化方法、基本类型和对象和字符串之间相互转化的方法。</li></ol><h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><ol><li>自动装箱过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中</li><li>自动拆箱过程：每当需要一个值时，被装箱对象中的值就被自动的提取出来，没必要再去调用intValue()和doubleValue()方法。</li><li>实际上我们的赋值语句是这样子。<code>Integer i = 100; -&gt; Integer i  = new Integer(100);</code></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ol><li>内部类可以使用外部所有方法与变量，就算是私有的也一样</li><li>内部类提供了在一个类中实现同一接口的多次机会</li></ol><h1 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h1><ol><li>多态</li><li>实现：一个类和一个接口</li><li>聚合：7个队员组成1个球队<ul><li>指新类中采用已有类的对象作为其成员变量，并增加其他的成员变量来表示其属性</li></ul></li><li>继承</li><li>关联：你和你的老师</li><li>泛化:某些类之间存在一般元素和特殊元素的关系</li><li>依赖：一种使用关系，表现为一样事物的改变会影响到使用它的其他事物。</li><li>组合：大体同聚合，但是部分必须依赖整体而存在，比如人和大脑</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 接口</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/10/07/java/java_接口/</id>
    <published>2019-10-07T05:52:05.694Z</published>
    <updated>2019-10-07T07:55:15.678Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>接口</strong></p><ol><li>为了实现外部定义与内部实现彻底分离，达到”相同接口，多种实现”的目的，java小红提供了”接口”<h1 id="Deadly-Dlamond"><a href="#Deadly-Dlamond" class="headerlink" title="Deadly Dlamond"></a>Deadly Dlamond</h1></li><li>java不支持多重继承，但是c++支持多重继承</li><li>而java允许多个接口</li></ol><h1 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h1><ol><li>定义方式: <code>public interface name{}</code></li><li>使用方式: <code>public class name implements name</code></li></ol><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li>纯抽象类，没有任何方法的定义，仅仅持有这些方法的声明<ol><li>接口中的数据成员在自动是static和final的，它们不能是空final，但是可以被非常量表达式初始化。</li><li>其中的抽象方法需要全部的实现<ol><li>接口方法在方法表中的位置不是固定的，调用方法需要查找<ol><li>invokeinterface会相对慢一些：需要在方法表中去查找</li></ol></li><li>接口方法和抽象方法不可以相互替代<ol><li>接口可以被类和接口多继承</li><li>但是抽象类只能被单继承</li><li>接口中没有this指针，没有构造函数，没有实例字段，无法保存状态，而抽象方法就可以</li><li>抽象类不能在java8中使用lambda表达式</li><li>在设计理念上，接口反映的是”like-a”关系，抽象类反映的是”is-a”关系</li></ol></li></ol></li><li>接口可以被嵌套在类或其他接口中</li></ol></li><li>我们可以通过继承接口来扩展接口</li></ol><h1 id="具体类和接口的使用"><a href="#具体类和接口的使用" class="headerlink" title="具体类和接口的使用"></a>具体类和接口的使用</h1><ol><li>显示地使用具体的类<ol><li>锁定某个具体的实现</li><li>丧失了可扩展性</li><li>丧失了灵活性</li></ol></li><li>按接口编程<ol><li>增加开发的可并行性</li><li>栈：后入先进</li><li>队列：先进先出</li></ol></li></ol><h1 id="链表的例子"><a href="#链表的例子" class="headerlink" title="链表的例子"></a>链表的例子</h1><ol><li>链表无法进行快速的查询，链表只能从头遍历</li><li>使用集合给的比要的要多</li><li>增加了耦合性</li><li>增加了出错了的概率</li></ol><h1 id="栈的例子"><a href="#栈的例子" class="headerlink" title="栈的例子"></a>栈的例子</h1><ol><li>Monitorable和stack组合</li><li>你依赖的东西是否有问题</li><li>不同类型的栈</li></ol><h1 id="字节码解释"><a href="#字节码解释" class="headerlink" title="字节码解释"></a>字节码解释</h1><ol><li>详见PPT</li></ol><h1 id="default-默认方法"><a href="#default-默认方法" class="headerlink" title="default 默认方法"></a>default 默认方法</h1><ol><li>default关键字只能在接口中使用(使用在switch中的default不能用在抽象类中)</li><li>这个用于解决为借口添加新方法而又不会破坏已有方法的实现，为升级旧接口且保持向后兼容提供了途径</li><li>默认方法的继承问题：可以重写，参见PPT</li><li>接口继承行为发生冲突时的解决规则：<ol><li>使用super来调用父类中的方法</li><li>当接口继承行为发生冲突时的另一个规则是，类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的。</li></ol></li><li>接口方法不能重写:Object类中的<code>equals、hashCode、toString</code></li><li>接口中的静态方法必须是public的，这个修饰符可以省略，但是static修饰符不可以被省略<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hi."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 方法</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/10/07/java/java_方法/</id>
    <published>2019-10-07T05:52:05.683Z</published>
    <updated>2019-10-07T07:55:02.037Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>方法</strong></p><ol><li>方法的概念：<ul><li>物理角度：指令块</li><li>逻辑角度：抽象指令单元</li><li>语义角度：行为</li></ul></li><li>分类：<ul><li>类的行为：方法</li><li>对象的行为：方法</li></ul></li></ol><h1 id="命名法"><a href="#命名法" class="headerlink" title="命名法"></a>命名法</h1><ol><li>第一个字母小写，之后的首字母大写。</li><li>一般用动词，或者动宾短语</li><li>和boolean相关的，isValid</li></ol><h1 id="方法的所有属性"><a href="#方法的所有属性" class="headerlink" title="方法的所有属性"></a>方法的所有属性</h1><ol><li>类的行为：<ol><li>静态方法</li><li>类名来调用</li></ol></li><li>对象的行为：<ol><li>成员方法</li><li>对象的引用来调用</li></ol></li></ol><h1 id="方法的意义"><a href="#方法的意义" class="headerlink" title="方法的意义"></a>方法的意义</h1><ol><li>逻辑封装</li><li>重用</li><li>可修改性</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>返回值</li><li>方法名</li><li>参数<ul><li>个数</li><li>类型</li><li>顺序</li></ul></li><li>抛出的异常</li></ul><h1 id="运行期："><a href="#运行期：" class="headerlink" title="运行期："></a>运行期：</h1><ul><li>程序执行的时间段</li><li>方法调用<ul><li>同步<ul><li>调用的方法和被调用的方法相关</li></ul><ol><li>每个方法只有一个入口。</li><li>被调用方法执行时，调用方法停止</li><li>调用结束后，程序控制权交换</li></ol></li><li>异步<ul><li>调用方法和被调用方法不相关</li></ul></li></ul></li></ul><h1 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h1><ul><li>public</li><li>private</li><li>protected</li><li>缺省（在一个包中）<h1 id="成员方法的声明"><a href="#成员方法的声明" class="headerlink" title="成员方法的声明"></a>成员方法的声明</h1>修饰词 返回类型 方法名称（参数列表){<br>方法<br>}  </li></ul><h1 id="成员方法的调用机制"><a href="#成员方法的调用机制" class="headerlink" title="成员方法的调用机制"></a>成员方法的调用机制</h1><ol><li>方法被同步调用的特性<ol><li>每个方法都只有一个入口</li><li>当执行被调用的方法的时候，调用方法暂停</li><li>当方法结束时，程序的控制权交还给调用处</li></ol></li><li>封装和闭包</li></ol><h1 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h1><ol><li>接口中的方法可以重载，但需要实现全部方法，也就是接口继承时<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2></li></ol><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ol><li>if</li><li>if else</li><li>switch(c)</li><li>switch(string)</li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ol><li>while</li><li>do while</li><li>for </li><li>for each syntax</li><li>特殊的关键字<ol><li>break</li><li>continue</li><li>return</li><li>exit:<br>返回0:返回正常值<br>返回-1：程序异常跳出<h1 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h1><code>return</code>返回值<br><code>exit</code>退出程序运行，返回0，正常，-1，错误退出</li></ol></li></ol><h1 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h1><h2 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写(Override)"></a>方法重写(Override)</h2><ol><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变</li><li>好处在于：子类可以根据需要特定于自己的行为</li><li>重写方法不能抛出新的检查异常或者比重写方法申明更加宽泛异常重写的方法要求被</li><li>要求原来的父类中必须有这个方法</li><li>方法的重写规则：<ol><li>参数列表必须完全与被重写方法的相同</li><li>返回类型可以与被重写方法的类型不相同，但是必须是父类返回值的派生类</li><li>访问权限不能比父类中重写的方法的访问权限更低。<code>public&lt;protected</code></li><li>父类的成员方法只能被它的子类重写</li><li>声明为final的方法不能被重写</li><li>声明为static的方法不能被重写，但是可以被再次声明</li><li>子类可以重写父类的方法：<ol><li>子类和父类同包时，可以重写所有除了声明为private和final的方法</li><li>子类和父类不同包时，那么子类只能重写父类声明为public和protected的非final方法</li></ol></li><li>构造方法不能被重写</li><li>如果不能继承一个方法，则不能重写这个方法</li><li>重写方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常<ul><li>不能抛出新的</li><li>不能抛出更广泛的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">programmer</span>()</span>&#123;</span><br><span class="line">    <span class="function">programmer <span class="title">game</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NJUCoder</span> <span class="keyword">extends</span> <span class="title">programmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">game</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">//编译错误，不能有不同返回值的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h2 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h2><ol><li>重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li><li>最常用的是构造器的重载</li><li>每个重载的方法必须有独一无二的参数类型列表</li><li>特点：<ul><li>变量类型</li><li>变量数量</li><li><strong>在同一个类内的不同的方法，只不过恰好名字相同。</strong></li><li>非法重载：<ol><li>只有标识符不同</li><li>只有返回值不同</li></ol></li></ul></li><li>代码重载规则：<ol><li>被重载的方法必须改变参数列表(参数数量或者类型不一样)</li><li>被重载的方法可以改变返回类型</li><li>被重载的方法可以改变访问修饰符</li><li>被重载方法可以声明新的或更广的检查异常</li><li>方法能够在同一类中或者在一个子类中被重载</li><li>无法以返回值类型作为重载函数的区分标准</li></ol></li></ol><h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><table><thead><tr><th>区别点</th><th>重载方法</th><th>重写方法</th></tr></thead><tbody><tr><td>参数列表</td><td>必须修改</td><td>一定不能修改</td></tr><tr><td>返回类型</td><td>可以修改</td><td>一定不能修改</td></tr><tr><td>异常</td><td>可以修改</td><td>可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td>访问</td><td>可以修改</td><td>一定不能做更严格的限制</td></tr></tbody></table><h1 id="方法调用的字节码"><a href="#方法调用的字节码" class="headerlink" title="方法调用的字节码"></a>方法调用的字节码</h1><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><ol><li>invokestatic:静态方法调用</li><li>invokespecial:实例构造器的<code>&lt;init&gt;</code>方法，私有方法和父类方法</li><li>invokevirtual:虚方法</li><li>invokeinterface:接口方法，会在运行时再确定一个实现此接口的对象</li><li>invokedynamic:会在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户有更高的自由度</li></ol><h2 id="overloading优先级"><a href="#overloading优先级" class="headerlink" title="overloading优先级"></a>overloading优先级</h2><ol><li>char&gt;int&gt;long&gt;character&gt;serializable&gt;object&gt;char…</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 高阶函数</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/07/java/java_高阶函数/</id>
    <published>2019-10-07T05:52:05.683Z</published>
    <updated>2019-10-07T07:55:05.606Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>java8以后的高阶函数</strong></p><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><ol><li>高阶函数是指接受另一个函数作为参数，或返回一个函数的函数。</li></ol><h2 id="高阶函数的例子"><a href="#高阶函数的例子" class="headerlink" title="高阶函数的例子"></a>高阶函数的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;?&gt; numUp = <span class="function">Stream <span class="title">of</span> <span class="params">(list)</span>.<span class="title">map</span><span class="params">(function)</span></span></span><br><span class="line"><span class="function">Stream&lt;?&gt; numbers </span>= <span class="function">Stream <span class="title">of</span> <span class="params">(list)</span>.<span class="title">filter</span><span class="params">(expr)</span></span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/rongrong_love_lc/article/details/72845528" target="_blank" rel="noopener">详见</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 集合</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/10/07/java/java_集合/</id>
    <published>2019-10-07T05:52:05.683Z</published>
    <updated>2019-10-07T07:55:09.419Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>集合</strong></p><h1 id="哈希（类似于-python-dict"><a href="#哈希（类似于-python-dict" class="headerlink" title="哈希（类似于 python dict)"></a>哈希（类似于 python dict)</h1><ol><li>HashMap 是一个用于储存Key-Value键对的集合。每一个键值对叫Entry,分散存储在一个数组中，作为一个主干，初始值null</li></ol><h1 id="List类："><a href="#List类：" class="headerlink" title="List类："></a>List类：</h1><h2 id="常见的list的初始化方式"><a href="#常见的list的初始化方式" class="headerlink" title="常见的list的初始化方式"></a>常见的list的初始化方式</h2><ol><li><p>构造List后使用List.add初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用双括号语法</p><ul><li>相当于定义了匿名内部类，会损失效率</li><li>如果返回List到其他地方可能会引起内存泄露<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> LinkedList&lt;String&gt;()&#123;&#123;</span><br><span class="line">   add(<span class="string">"a"</span>);</span><br><span class="line">   add(<span class="string">"b"</span>);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用Arrays.asList的内部静态方法</p><ol><li>返回的是Arrays的静态内部类<ul><li>静态类继承自AbstractList，实现RandomAccess，内部使用数组来存储元素，但是不支持增删元素</li></ul></li><li>尽量避免使用int基本类型，和[]这种底层的数据结构，相应的应当尽量使用List和Integer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList  = Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用高阶函数Stream(JDK8)</p><ol><li>略微有点大材小用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; List = Stream.of(<span class="string">"a"</span>,<span class="string">"b"</span>).collect(Collectors.toList())</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用Lists(JDK9)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="集合关系运算"><a href="#集合关系运算" class="headerlink" title="集合关系运算"></a>集合关系运算</h2><ol><li>求并集:<code>list1.addAll(list2)</code></li><li>求交集:<code>list1.retainAll(list2)</code></li><li>求补集:<code>list1.removeAll(list2)</code></li></ol><h1 id="Map类："><a href="#Map类：" class="headerlink" title="Map类："></a>Map类：</h1><ol><li>用于存储元素对(称作”键”和”对”)。</li><li>类型介绍：<ol><li>通用MAP</li><li>专用MAP</li><li>用于帮助我们实现自己的MAP类的抽象类</li></ol></li><li>类型区别<ol><li>HashMap:<em>最常用</em>  <blockquote><p>用HashCpde值存储数据，访问数据，非同步的 </p></blockquote></li><li>TreeMap:  <blockquote><p>能够把它保存的记录根据键值进行升序排序，也可以制定排序的比较器。<br>不允许Key的值为null.不同步.  </p></blockquote></li><li>Hashtable：  <blockquote><p>Key和value均不允许为null，它支持线程的同步，写入时较慢。  </p></blockquote></li><li>LinkedHashMap:  <blockquote><p>保存了记录的插入顺序，用Iterator遍历时，先得到的记录是先插入的。<br>Key和value不可以为空，非同步的。  </p></blockquote></li></ol></li><li>常用语法  </li></ol><table><thead><tr><th>代码</th><th>作用</th></tr></thead><tbody><tr><td><code>Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</code></td><td>用于初识化一个链表</td></tr><tr><td><code>map.put(&quot;key1&quot;,&quot;value1&quot;);&quot;</code></td><td>用于插入元素</td></tr><tr><td><code>map.get(&quot;key1&quot;);</code></td><td>用于获取元素</td></tr><tr><td><code>map.remove(&quot;key1&quot;);</code></td><td>用于移除元素</td></tr><tr><td><code>map.clear</code></td><td>用于清空整个链表</td></tr><tr><td><code>map.Keyset()</code></td><td>用于增强for进行增强遍历(例子参见1)</td></tr><tr><td><code>map.entrySet()</code></td><td>用于增强for进行另一种增强遍历(例子参见2)</td></tr><tr><td><code>map.putAll(Map t)</code></td><td>将指定的Map中的所有映射复制到这个map</td></tr><tr><td><code>map.containsKey(Object key)</code></td><td>如果Map包含指定键的映射，返回true</td></tr><tr><td><code>map.containsValue(Object value)</code></td><td>如果map将一个或多个键映射到指定值，则返回true</td></tr><tr><td><code>map.isEmpty()</code></td><td>如果Map不包含键-值映射，则返回true</td></tr><tr><td><code>map.size()</code></td><td>返回Map中的键-值映射的数目</td></tr></tbody></table><ol><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">System.out.println(key + <span class="string">" ："</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">" ："</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>迭代可以直接进行迭代，也可以用迭代器进行迭代。  </li></ol><h1 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h1><ol><li>是数组队列，相当于动态数组，不同于Vector的是，这个类并不是线程安全的，也就是最好只在单线程中使用。</li><li>构造函数  </li></ol><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td><code>ArrayList</code></td><td>默认构造函数</td></tr><tr><td><code>ArrayList(int capacity)</code></td><td>设置这个数组的默认大小，如果不够的话一次添加上一次容量的一半</td></tr><tr><td><code>ArrayList(Collection&lt;? extends E&gt; collection)</code></td><td>创建一个包含collection的ArrayList</td></tr><tr><td>3. API(常用)</td><td></td></tr></tbody></table><table><thead><tr><th>返回值</th><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>boolean</td><td>add(E object)</td><td>添加项</td></tr><tr><td>boolean</td><td>addAll(collection&lt;? extends E&gt;collection)</td><td>移除全部项</td></tr><tr><td>void</td><td>clear()</td><td>清空</td></tr><tr><td>boolean</td><td>contains(Object object)</td><td>判断是否包含</td></tr><tr><td>boolean</td><td>containsAll(collection&lt;? extends E&gt;collection)</td><td>判断是否全部包含</td></tr><tr><td>boolean</td><td>equals(Object object)</td><td>判断是否相同</td></tr><tr><td>int</td><td>hashCode()</td><td>根据对象的地址或者字符串或者数字算出来的int型的数值</td></tr><tr><td>boolean</td><td>isEmpty()</td><td>判断是否为空</td></tr><tr><td>boolean</td><td>remove(Object object)</td><td>移除元素</td></tr><tr><td>boolean</td><td>removeAll(collection&lt;? extends E&gt;collection)</td><td>移除全部这些元素</td></tr><tr><td>boolean</td><td>retainAll(collection&lt;? extends E&gt;collection)</td><td>取交集</td></tr><tr><td>int</td><td>size()</td><td>返回这个链表的长度</td></tr><tr><td></td><td>get()</td><td>按照索引访问元素</td></tr><tr><td>&lt;a href = “<a href="https://www.cnblogs.com/skywang12345/p/3308556.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3308556.html</a></td><td></td><td></td></tr><tr><td>“&gt;查询详情</td><td></td><td></td></tr></tbody></table><h1 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h1><ol><li>实现自动增长的对象数组</li><li><a href="https://www.cnblogs.com/zheting/p/7708366.html" target="_blank" rel="noopener">详见</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 继承和多态</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2019/10/07/java/java_继承和多态/</id>
    <published>2019-10-07T05:52:05.683Z</published>
    <updated>2019-10-07T07:55:12.355Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><h1 id="java学习笔记之继承和多态"><a href="#java学习笔记之继承和多态" class="headerlink" title="java学习笔记之继承和多态"></a>java学习笔记之继承和多态</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol><li>继承是指利用已有类的形式，并添加新的成员变量和方法来构建新的类。</li><li>父类不可以强制类型转换成子类</li><li>java单一继承，而不是多继承<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">            Base b = <span class="keyword">new</span> Base();</span><br><span class="line">            Sub s = (Sub) b;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; <span class="comment">//编译通过，但运行是出错</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="继承源起"><a href="#继承源起" class="headerlink" title="继承源起"></a>继承源起</h3><ol><li>避免重复代码</li><li>分类、抽象的概念</li><li>根父类：Object<ol><li>toString()方法</li><li>equals()方法</li><li>wait()方法</li></ol></li></ol><h3 id="继承特点"><a href="#继承特点" class="headerlink" title="继承特点"></a>继承特点</h3><ol><li>子类继承了父类所有成员变量和方法</li><li>继承可以增加成员变量和成员方法</li><li>继承可以覆盖父类的成员方法</li><li>继承不可以覆盖父类的成员变量<ul><li>父类中的方法如果是private，不能调用子类重写的方法</li></ul></li><li>重名方法会调用继承树最下方部分的方法</li><li>父类设置了一种契约，所有的子类都会承受这个契约</li><li><strong>任何一个子类对象都可以当做父类来看待</strong></li><li>子类写的和父类同名的方法算一个方法，是对父类的重写</li><li>子类变量可以被赋值给父类引用</li><li><strong>父类不可以强制类型转换成子类</strong></li></ol><h3 id="问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？"><a href="#问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？" class="headerlink" title="问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？"></a>问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？</h3><ol><li>能够继承父类的私有变量</li><li>但是不能直接访问父类的私有变量</li></ol><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><ol><li>如果你在子类中重写了父类的方法，但是想要使用父类中未被重写的方法，那么使用super关键字来完成引用  </li><li>几个实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">father</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">son</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="IS-A-amp-amp-HAS-A-amp-amp-USES-A-amp-amp-OWNS-A"><a href="#IS-A-amp-amp-HAS-A-amp-amp-USES-A-amp-amp-OWNS-A" class="headerlink" title="IS-A&amp;&amp;HAS-A&amp;&amp;USES-A&amp;&amp;OWNS-A"></a>IS-A&amp;&amp;HAS-A&amp;&amp;USES-A&amp;&amp;OWNS-A</h3><ol><li>IS-A是继承机制</li><li>HAS-A是是否被继承机制</li><li>USES-A是依赖关系</li><li>HAS-A是关联关系</li><li>OWNS-A是聚合关系</li><li>IS-A-PART-OF是组合关系</li></ol><h3 id="父类对于子类的影响"><a href="#父类对于子类的影响" class="headerlink" title="父类对于子类的影响"></a>父类对于子类的影响</h3><ol><li>父类的接口的更改会影响所有的子类的接口。</li><li>子类继承父类的私有变量、接口等。</li><li>从构造方法开始，向上调用父类方法</li><li>编译器会自动帮你调用super()(也就是无参数的构造函数)，而如果写的话必须在开头</li><li>从接口来看：<ol><li>子类必须保持和父类同样的接口</li><li>子类必须继承了父类的实现</li><li>一旦父类脆弱发生变化，就会对子类造成很大的麻烦</li></ol></li></ol><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><ol><li>一个类里面有一个属性，将一个fruit组合进入Apple中</li><li>允许你在新的类中设置子对象，组合是显式的这样做，而继承是隐式的这样做。</li><li>使用组合关系时，前端接口和后端接口没有直接关系，只要修改实现就好</li><li>组合主要用于想要在新类中使用现有类的功能而并不是它的接口的情形</li></ol><h2 id="对于继承和组合的选择"><a href="#对于继承和组合的选择" class="headerlink" title="对于继承和组合的选择"></a>对于继承和组合的选择</h2><ol><li>确保有继承关系</li><li>不要使用继承去完成代码的重载</li><li>确认父类方法的接口稳定性</li></ol><h2 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h2><ol><li>特点：<ol><li>对已有实现的修改</li><li>对新的实现的扩展</li><li>对实现的动态配置</li></ol></li></ol><h3 id="用户端代码"><a href="#用户端代码" class="headerlink" title="用户端代码"></a>用户端代码</h3><ol><li>特点：<ol><li>大量的</li><li>分散的</li><li>如何发生修改重新编译的话，是需要大量时间的<blockquote><p>不想要更改</p></blockquote></li></ol></li><li>构造方法没有多态</li></ol><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li>多态是指多个成员变量或成员方法采用相同的标识符，并且在使用该标识符时确认应该使用哪个成员变量或成员方法。</li><li>所有类的父类:Object<ol><li><code>equals(Object o)</code>指示某个其他对象是否与此对象“相等”。 </li><li><code>getClass()</code>返回一个对象的运行时类。</li><li><code>hashCode()</code>返回该对象的哈希码值。</li><li><code>toString()</code>返回该对象的字符表示。</li></ol></li><li>多态的代价：Object不能添加Dog类型的变量。</li><li>编译时，编译器决定你是否能调用某个方法<ul><li>依据引用变量的类型，而不是引用变量指向的对象的类型</li></ul></li><li>执行时，JVM虚拟机决定实际那个方法被调用<ul><li>依据实际引用变量指向的对象的类型</li></ul></li><li>多态的思想:分离”做什么”和”怎么做”，从另一角度将接口和实现分离开来。</li><li>Overriding规则:<ol><li>参数必须一致，返回值必须兼容</li><li>方法的可达性不可降低(private、public)</li><li>不可以覆盖私有方法，因为父类私有方法自动添加final</li></ol></li><li>Overloading<ol><li>静态分派：<ol><li>优先级:char&gt;int&gt;long&gt;Character&gt;Serializable&gt;Object&gt;char…</li><li>如果不存在char的，优先匹配int，以此类推</li><li>编译的时候就已经决定了这个调用的优先顺序</li></ol></li><li>动态分派：<ol><li>在编译器中，重写的方法被视作了一个方法</li><li>按照类型进行分派</li></ol></li></ol></li></ol><h2 id="方法的字节码调用"><a href="#方法的字节码调用" class="headerlink" title="方法的字节码调用"></a>方法的字节码调用</h2><ol><li>参PPT</li></ol><h1 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h1><ol><li>步骤如下：  <ol><li>首先加载一条链上的各个类</li><li>先进行静态初始化，优先初始化父类，之后初始化子类</li><li>将所有的成员变量先设置为0系的初值</li><li>开始调用父类的构造方法，一条链向上</li><li>将所有的成员变量按照字面顺序初始化</li><li>剩余的所有的部分的初始化</li></ol></li><li>考察构造顺序</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 泛型</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/07/java/java_泛型/</id>
    <published>2019-10-07T05:52:05.683Z</published>
    <updated>2019-10-07T07:54:59.257Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><h1 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h1><ol><li>泛型:即参数化类型。</li><li>其本质是为了参数化类型(在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参来控制形参具体限制的类型)</li><li>泛型可以让部分错误在编译阶段可以被发现。</li></ol><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol><li>泛型只在编译阶段是有效的，在编译之后，程序会采取泛型化的措施</li><li>总而言之:泛型类型在逻辑上可以看成十多个不同的类型，但实际上都是相同的基本类型。</li></ol><h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><ol><li>三种使用方式:泛型化、泛型接口和泛型方法</li></ol><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ol><li><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。</p></li><li><p>相应的泛型类的例子:list、Set、Map。</p></li><li><p>泛型类的最基本写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基本的泛型类的示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型类:泛型的时候传入泛型实参，则会根据传入的泛型实参做相应的限制，这时候才会应起到的限制作用。</p></li></ol><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><ol><li>泛型接口与泛型类的定义及使用基本相同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="参考网页"><a href="#参考网页" class="headerlink" title="参考网页"></a>参考网页</h1><p><a href="https://www.cnblogs.com/coprince/p/8603492.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 变量</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2019/10/07/java/java_变量/</id>
    <published>2019-10-07T05:52:05.674Z</published>
    <updated>2019-10-07T07:54:56.383Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>变量</strong></p><h1 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h1><ol><li>不同角度看变量：<ol><li>物理角度：计算机的数据存储单元</li><li>逻辑角度：计算机模型中的抽象数据单位</li><li>语义角度：类的属性、方法的状态</li></ol></li><li>赋值：改变现实对象的状态<ol><li>通过赋值来改变模拟变量状态的<strong>程序设计语言常规的符号名字</strong></li><li>赋值打破了引用透明性</li><li>与所有状态必须显示地操作的传递额外的参数的方式相比，通过引进赋值和将状态隐藏在局部变量的技术。我们能以一种更模块化的方式构造系统</li></ol></li></ol><h1 id="变量的属性"><a href="#变量的属性" class="headerlink" title="变量的属性"></a>变量的属性</h1><ol><li>types:强类型语言<ol><li>基础数据类型<ol><li>物理视角</li><li>使用预定义好的、基础的数据类型</li><li>其中主类型和别的类型是不同的，比如int&amp;&amp;Integer,double&amp;&amp;Double</li></ol></li><li>引用类型<ol><li>来源与语义视角</li><li>对象的遥控器</li></ol></li></ol></li><li>values：<ol><li>值<ol><li>基础数值类型：浮点数类型有精度损失</li></ol></li></ol></li><li>variables</li></ol><h2 id="变量的标识符"><a href="#变量的标识符" class="headerlink" title="变量的标识符"></a>变量的标识符</h2><ol><li>必须由字母、下划线、或者美元符开头</li><li>区分大小写</li><li>不允许包含有空格和制表符</li><li>符合命名规则的好处：<ol><li>有助于在项目间传递知识</li><li>在新的项目中更加快速的学习代码</li><li>减少名字的增生</li><li>弥补编程语言的不足</li></ol></li><li>java命名规则：<ol><li>除了变量名以外，类、类常量，均使用大小写混合的方法</li><li>第一个单词的首字母小写，其后单词的首字母大写</li><li>变量名不应该以下划线或美元符号开头</li></ol></li></ol><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>命名：应该全部大写，单词间用下划线分隔</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><ol><li>变量的地址是与这个变量相关联的地址</li><li>多个变量可以具有同一地址当用多个变量名来访问单个存储地址时，这些变量名就成为了别名</li></ol><h3 id="很特殊的字符串"><a href="#很特殊的字符串" class="headerlink" title="很特殊的字符串"></a>很特殊的字符串</h3><ol><li>==比较的是地址，<code>.equals()</code>比较的是内部的值</li><li>new String(str):可以强制分配对象</li><li>相同字符串一般情况下只保存一个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String();</span><br><span class="line">a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String();</span><br><span class="line">b = <span class="string">"abc"</span>;</span><br><span class="line">System.out.print(a==b);<span class="comment">//true,分配两个对象，指向一个对象</span></span><br><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br><span class="line">System.out.print(a==b);<span class="comment">//true，直接指向同一个</span></span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">System.out.print(a==b);<span class="comment">//false，强制分配两个</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h2><ol><li>生存期是该变量绑定于某一特定存储地址的时间</li><li>变量的生存期：<ol><li>静态变量</li><li>栈动态变量</li><li>显性堆动态变量</li><li>隐性堆动态变量</li></ol></li></ol><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol><li>速度较快</li><li>要求在编译的时候知道变量占用内存空间的大小和时间——局部变量</li></ol><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol><li>效率较低</li><li>不需要让编译器知道所占有内存空间的大小和时间</li><li>在离开其作用域后虽然无法访问，但是依旧占据着内存空间</li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol><li>语句的一个范围，在这个范围之内，变量为可见的。如果一个变量在一条语句中可以被引用，这个变量即在这条语句中为可见的</li><li>一般和代码块相关</li><li>成员变量在类中声明，整个类中可见，涉及到访问权限的问题</li><li>如果是使用成员变量，使用this关键字</li></ol><h1 id="变量的行为"><a href="#变量的行为" class="headerlink" title="变量的行为"></a>变量的行为</h1><h2 id="构成声明语句"><a href="#构成声明语句" class="headerlink" title="构成声明语句"></a>构成声明语句</h2><h2 id="和操作符结合成为表达式"><a href="#和操作符结合成为表达式" class="headerlink" title="和操作符结合成为表达式"></a>和操作符结合成为表达式</h2><h2 id="初始化（对象）"><a href="#初始化（对象）" class="headerlink" title="初始化（对象）"></a>初始化（对象）</h2><ol><li>对象的初识化的顺序：<ol><li>静态成员变量</li><li>静态初始化块</li><li>非静态成员变量</li><li>构造器中初始化</li><li>所有的成员变量都会在构造器执行之前被初始化为指定的值或默认值，在构造器中如果有对其赋值的语句将会再次对其进行初始化</li></ol></li></ol><h1 id="常用变量的用法"><a href="#常用变量的用法" class="headerlink" title="常用变量的用法"></a>常用变量的用法</h1><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol><li>局部变量(在方法内部)<ul><li>用于在方法内部临时存放数据</li><li>不管是数据类型还是引用类型，如果在没有显示初始化的情况下使用，都会出现错误</li></ul></li><li>属性字段(在对象内部)<ul><li>用于存放表示类的属性的值</li></ul></li><li>静态变量(全局)<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2></li><li>直接访问(内部使用者)</li><li>间接访问(外部使用者)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 BigDecimal</title>
    <link href="http://yoursite.com/2019/10/07/java/java_BigDecimal/"/>
    <id>http://yoursite.com/2019/10/07/java/java_BigDecimal/</id>
    <published>2019-10-07T05:52:05.674Z</published>
    <updated>2019-10-07T07:55:54.095Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>java变量类型——BigDecimal</strong></p><ol><li>java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。</li><li>float和double只能用来做科学计算和工程计算，而在商业运算中我们要使用BigDecimal</li></ol><h1 id="获得BigDecimal类的对象"><a href="#获得BigDecimal类的对象" class="headerlink" title="获得BigDecimal类的对象"></a>获得BigDecimal类的对象</h1><ol><li>将BigDecimal转换存Double:<ul><li>推荐使用<code>new BigDecimal(num+&quot;&quot;)</code></li><li>尽量避免使用<code>new BigDecimal(num)</code>，因为这样会有比较多的无效位数。</li></ul></li><li>除此以外，我们可以通过写数字的值或者string来创建BigDecimal类型。<ul><li>尽量选择string因为其精度高</li></ul></li></ol><h1 id="BigDecimal类的运算"><a href="#BigDecimal类的运算" class="headerlink" title="BigDecimal类的运算"></a>BigDecimal类的运算</h1><ol><li>必须都是BigDecimal对象才能被使用。</li></ol><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><ol><li>add()函数</li></ol><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><ol><li>substract()函数</li></ol><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><ol><li>multiply()函数</li></ol><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><ol><li>divide(BigDecimal,scale,舍入方式)函数<ul><li>在指定情况下，我们需要指定scale位数来确定精度。</li></ul></li></ol><h2 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h2><ol><li>abs()函数</li></ol><h2 id="带余除法"><a href="#带余除法" class="headerlink" title="带余除法"></a>带余除法</h2><ol><li><code>public BigDecimal[] divideAndRemainder(BigDecimal divisor)</code></li><li>接受一个BigDecimal对象作为参数，该参数即为除数，返回一个BigDecimal数组。<ul><li>数组中包含两个元素:第一个元素为两数相除的商，第二个元素是除数。</li></ul></li></ol><h1 id="其他的BigDecimal的API"><a href="#其他的BigDecimal的API" class="headerlink" title="其他的BigDecimal的API"></a>其他的BigDecimal的API</h1><ol><li><code>stripTrailingZeros()</code>将其格式化一个相等的，但去掉了末尾0的BigDecimal</li></ol><h1 id="BigDecimal舍入模式"><a href="#BigDecimal舍入模式" class="headerlink" title="BigDecimal舍入模式"></a>BigDecimal舍入模式</h1><ol><li>属于java.math.RoundingMode</li></ol><h2 id="ROUND-UP"><a href="#ROUND-UP" class="headerlink" title="ROUND_UP"></a>ROUND_UP</h2><ol><li>舍入远离零的舍入模式。在丢弃非零部分之前始终增加数字。(始终对非零舍弃部分前面的数字加1)</li><li>这个舍入模式始终不会减少计算值的大小</li></ol><h2 id="ROUND-DOWN"><a href="#ROUND-DOWN" class="headerlink" title="ROUND_DOWN"></a>ROUND_DOWN</h2><ol><li>接近零的舍入模式。在对齐某部分之前始终不增加数字(从不对舍弃部分前面的数字加1，即截断)。</li><li>这个舍入模式始终不会增加计算值的大小。</li></ol><h2 id="ROUND-CEILING"><a href="#ROUND-CEILING" class="headerlink" title="ROUND_CEILING"></a>ROUND_CEILING</h2><ol><li>接近正无穷大的舍入模式。如果为正，和ROUND_UP相同。若为负，则相反。</li><li>此舍入模式始终不会减少计算值。</li></ol><h2 id="ROUND-FLOOR"><a href="#ROUND-FLOOR" class="headerlink" title="ROUND_FLOOR"></a>ROUND_FLOOR</h2><ol><li>接近负无穷大的舍入模式。如果为正，则舍入行为和ROUND_DOWN相同。若为负，则和ROUND_UP相同。</li><li>此舍入模式始终不会增加计算值。</li></ol><h2 id="ROUNG-HALF-UP"><a href="#ROUNG-HALF-UP" class="headerlink" title="ROUNG_HALF_UP"></a>ROUNG_HALF_UP</h2><ol><li>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同。</li><li>也就是我们学的四舍五入。</li></ol><h2 id="ROUND-HALF-DOWN"><a href="#ROUND-HALF-DOWN" class="headerlink" title="ROUND_HALF_DOWN"></a>ROUND_HALF_DOWN</h2><ol><li>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。<br>如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同;否则舍入行为与 ROUND_DOWN 相同(五舍六入)。</li></ol><h2 id="ROUND-HALF-EVEN"><a href="#ROUND-HALF-EVEN" class="headerlink" title="ROUND_HALF_EVEN"></a>ROUND_HALF_EVEN</h2><ol><li>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同;</li><li>如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。</li><li>注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。</li><li>此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况。如果前一位为奇数，则入位，否则舍去。以下例子为保留小数点1位，那么这种舍入方式下的结果。<ul><li>1.15&gt;1.2 1.25&gt;1.2</li></ul></li></ol><h2 id="ROUND-UNNESSARY"><a href="#ROUND-UNNESSARY" class="headerlink" title="ROUND_UNNESSARY"></a>ROUND_UNNESSARY</h2><ol><li>断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.cnblogs.com/jpfss/p/9987319.html" target="_blank" rel="noopener">星朝</a></li><li><a href="https://blog.csdn.net/bailu666666/article/details/79829902" target="_blank" rel="noopener">java大数类</a></li></ol><h1 id="转换为相应类型进行返回"><a href="#转换为相应类型进行返回" class="headerlink" title="转换为相应类型进行返回"></a>转换为相应类型进行返回</h1><ol><li>toString()将BigDecimal对象的数值转换成字符串。    </li><li>doubleValue()将BigDecimal对象中的值以双精度数返回。   </li><li>floatValue()将BigDecimal对象中的值以单精度数返回。   </li><li>longValue()将BigDecimal对象中的值以长整数返回。    </li><li>intValue()将BigDecimal对象中的值以整数返回。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 编码规范</title>
    <link href="http://yoursite.com/2019/10/07/java/java_java%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2019/10/07/java/java_java编码规范/</id>
    <published>2019-10-07T05:52:05.674Z</published>
    <updated>2019-10-07T09:26:11.379Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>Java学习笔记之java编码规范</strong></p><ol><li>这是关乎开发效率和后期维护的考虑</li><li>2019/06/17 by stormbroken</li></ol><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><ol><li>增加可读性，减少项目组中因为换人而带来的损失</li><li>具体的规范<ol><li>Package:由一个小写单词组成</li><li>Class:有大写字母开头，其他字母都小写的单词</li><li>Class的变量、参数：由一个小写字母开头，后面的单词由大写字母开头</li><li>static &amp; final 的变量:都应该大写，并且指出完整含义</li><li>方法的参数：尽量保证和要赋值的字段名字相同</li></ol></li></ol><h1 id="Java文件样式"><a href="#Java文件样式" class="headerlink" title="Java文件样式"></a>Java文件样式</h1><ol><li>所有的java文件都应该遵守如下的样式规则</li></ol><h2 id="版权信息：版权信息必须在java文件的开头"><a href="#版权信息：版权信息必须在java文件的开头" class="headerlink" title="版权信息：版权信息必须在java文件的开头"></a>版权信息：版权信息必须在java文件的开头</h2><ul><li>比如:其他不需要出现在javadoc中的信息也可以包含在这里，参见例一</li></ul><h2 id="Package和Imports："><a href="#Package和Imports：" class="headerlink" title="Package和Imports："></a>Package和Imports：</h2><p>package在import前，import中的标准包名要在本地包名前，并且按照字母顺序排列，其中*保证导入所有的信息</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class:"></a>Class:</h2><ol><li>类的注释，一般是用来解释类的，(参见例二)</li><li>类定义</li><li>类的成员变量:public的成员变量必须生成文档(JavaDoc)，protected、private、package定义的成员变量如果名字含义明确，可以没有注释</li></ol><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ol><li>存取方法：类变量的存取方法，可以简单地把只用于存取的方法写在一行上</li><li>克隆方法：如果一个类是可以被克隆的，下一步就是clone方法，（例三）</li><li>类方法：<ol><li>toString方法：每一个类都应该有的方法</li><li>其他方法</li></ol></li><li>main方法：应当被写在类的底部</li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h2><p>构造函数应该按照递增的方式写，参数多的写在后面，(并且访问类型应该在一行中，方法和参数写下一行)</p><h2 id="例子们"><a href="#例子们" class="headerlink" title="例子们"></a>例子们</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**(例一) </span></span><br><span class="line"><span class="comment">* Copyright ? 2000 Shanghai XXX Co. Ltd. </span></span><br><span class="line"><span class="comment">* All right reserved. </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* A class representing a set of packet and byte counters </span></span><br><span class="line"><span class="comment">* It is observable to allow it to be watched, but only </span></span><br><span class="line"><span class="comment">* reports changes when the current set is complete </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> </span><br><span class="line"><span class="function">Object <span class="title">clone</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        CounterSet obj = (CounterSet)<span class="keyword">super</span>.clone(); </span><br><span class="line">        obj.packets = (<span class="keyword">int</span>[])packets.clone(); </span><br><span class="line">        obj.size = size; </span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    &#125;<span class="keyword">catch</span>(CloneNotSupportedException e) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Unexpected CloneNotSUpportedException: "</span> + e.getMessage()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码编写格式"><a href="#代码编写格式" class="headerlink" title="代码编写格式"></a>代码编写格式</h1><h2 id="代码样式"><a href="#代码样式" class="headerlink" title="代码样式"></a>代码样式</h2><ul><li>代码应该使用unix的格式，而不是windows格式<ul><li>回车变为回车+换行</li></ul></li></ul><h2 id="文档化"><a href="#文档化" class="headerlink" title="文档化"></a>文档化</h2><ul><li>必须用javadoc来生成文档<ol><li>是文档的标准，被各种java编译器都认可的方法</li><li>@author标记不被推荐</li></ol></li></ul><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><ul><li>缩进每行两个空格，而不是一个Tab，因为Tab在不同设置不同编译器中是不同的</li></ul><h2 id="页宽"><a href="#页宽" class="headerlink" title="页宽"></a>页宽</h2><ul><li>页宽设置为80字符</li><li>特别长的剧应该一个逗号或者操作符后折行，并且折行后比原来的语句在缩进2个字符</li></ul><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><ul><li>左括号和后一个字符之间不应该出现空格</li><li>右括号和前一个字符之间不应该出现空格</li><li>避免在语句中使用无意义的括号，括号只应该为达到某种目的而出现在源代码中</li></ul><h1 id="程序编写规范"><a href="#程序编写规范" class="headerlink" title="程序编写规范"></a>程序编写规范</h1><h2 id="exit-函数"><a href="#exit-函数" class="headerlink" title="exit()函数"></a>exit()函数</h2><ol><li>exit除了在main中可以被调用外，其他地方不应该调用，因为这样子不给任何代码机会来截获退出</li><li>一个类似后台五福的程序不应该因为某一个库模块决定要退出就退出</li></ol><h2 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h2><ol><li>申明的错误应该抛出一个RuntimeException或者派生的异常</li><li>顶层main函数应截获所有的异常，并且打印在屏幕上\记录在日志中</li></ol><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><ol><li>java使用成熟的后台垃圾收集技术来代替引用技术</li><li>这样子做的话，必须要在使用完对象的实例后进行清场工作</li></ol><h2 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h2><ol><li>不要因为性能的原因将一个类定义为final的，除非框架需要<ol><li>如果一个类还没被准备好进行继承，最好在类文档中注明，而不要定义为final的</li><li>有可能在以后会用到相应的继承</li></ol></li></ol><h2 id="访问类的成员变量"><a href="#访问类的成员变量" class="headerlink" title="访问类的成员变量"></a>访问类的成员变量</h2><ol><li>大部分类的成员变量应该定义为protected的来放置继承类使用他们</li></ol><h1 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h1><h2 id="byte数组转换成characters"><a href="#byte数组转换成characters" class="headerlink" title="byte数组转换成characters"></a>byte数组转换成characters</h2><p>使用<code>.getBytes()</code>即可</p><h2 id="Utility类-仅仅提供方法的类"><a href="#Utility类-仅仅提供方法的类" class="headerlink" title="Utility类(仅仅提供方法的类)"></a>Utility类(仅仅提供方法的类)</h2><p>这个类应该被申明为防止被继承或被初始化</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ol><li>定义的部分可以在之间使用==进行比较</li><li>但是和其他的等价部分只能使用equal进行比较</li></ol><h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><ol><li>避免使用AWT组件</li><li>尽量避免混合使用AWT和Swing组件</li><li>AWT组件不要用JscrollPane类来实现滚动使用AWT ScrollPane</li><li>避免在InternalFrame组件中使用AWT组件</li></ol><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ol><li>一个重要的部分</li><li>在软件生命周期的各个部分，吊事能够用配置开、关是最基本的。</li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li>时刻记住我们应该注意代码的效率</li><li>当我们没有时间实现一个高效的算法时，我们需要在文档中记录下来，以后有空的时候在实现她。</li></ol><h2 id="使用StringBuffer对象"><a href="#使用StringBuffer对象" class="headerlink" title="使用StringBuffer对象"></a>使用StringBuffer对象</h2><ol><li>保障减少很多不必要的创建和释放对象的时间</li></ol><h2 id="避免synchroized关键字"><a href="#避免synchroized关键字" class="headerlink" title="避免synchroized关键字"></a>避免synchroized关键字</h2><ol><li>防止死锁</li><li>保障程序的可移植性</li></ol><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ol><li>尽量用println来代替在字符串中使用”\n”</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 GUI</title>
    <link href="http://yoursite.com/2019/10/07/java/java_GUI/"/>
    <id>http://yoursite.com/2019/10/07/java/java_GUI/</id>
    <published>2019-10-07T05:52:05.674Z</published>
    <updated>2019-10-07T07:55:57.076Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><h1 id="java学习笔记之GUI"><a href="#java学习笔记之GUI" class="headerlink" title="java学习笔记之GUI"></a>java学习笔记之GUI</h1><ol><li>代码默写按点给分，不会太细节</li></ol><h2 id="GUI综述"><a href="#GUI综述" class="headerlink" title="GUI综述"></a>GUI综述</h2><ol><li>GUI：Graphical user interface</li><li>WIMP:window,icon,menu,pointer</li><li>WYSIWYG:What-You-See-Is-What-You-Get</li></ol><h2 id="GUI的关键部分以及GUI的创建"><a href="#GUI的关键部分以及GUI的创建" class="headerlink" title="GUI的关键部分以及GUI的创建"></a>GUI的关键部分以及GUI的创建</h2><ol><li>组件Component</li><li>布局Layout</li><li>事件Event</li></ol><h3 id="GUI的创建"><a href="#GUI的创建" class="headerlink" title="GUI的创建"></a>GUI的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JFrame frame = <span class="keyword">new</span> JFrame();<span class="comment">//创建frame框架</span></span><br><span class="line">JButton button = <span class="keyword">new</span> JButton(str);<span class="comment">//创建一个str的按钮</span></span><br><span class="line">frame.getContentPane().add(button);<span class="comment">//获得当前框架主体，添加button</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">//这一行程序会在window关闭时把程序结束</span></span><br><span class="line">frame.setSize(<span class="number">300</span>,<span class="number">300</span>);<span class="comment">//设置frame大小</span></span><br><span class="line">frame.setVisible(<span class="keyword">true</span>);<span class="comment">//设置frame可见</span></span><br></pre></td></tr></table></figure><h2 id="所有组件的根父类"><a href="#所有组件的根父类" class="headerlink" title="所有组件的根父类"></a>所有组件的根父类</h2><ol><li>Component</li></ol><h2 id="GUI发展过程"><a href="#GUI发展过程" class="headerlink" title="GUI发展过程"></a>GUI发展过程</h2><ol><li>AWT</li><li>Swing</li><li>SWT</li><li>JavaFx</li></ol><h2 id="事件和布局"><a href="#事件和布局" class="headerlink" title="事件和布局"></a>事件和布局</h2><ol><li>首先有一个窗口</li><li>组件</li></ol><table><thead><tr><th>组件名称</th><th>组件内容</th></tr></thead><tbody><tr><td><code>JFrame</code></td><td>窗口</td></tr><tr><td><code>Button</code></td><td>按钮</td></tr><tr><td><code>Image</code></td><td>图片</td></tr><tr><td><code>Color</code></td><td>颜色元素</td></tr></tbody></table><ol start="3"><li>具体行为</li></ol><table><thead><tr><th>相应行为</th><th>意义</th></tr></thead><tbody><tr><td><code>frame.getContentPane().add(Button)</code></td><td>布局按钮</td></tr><tr><td><code>setVisible(true)</code></td><td>设置为可见</td></tr><tr><td><code>setSize(300,300)</code></td><td>设置控件大小</td></tr><tr><td><code>new ImageIcon(&quot;name.jpg&quot;).getImage()</code></td><td>获取一个图像的布局</td></tr><tr><td><code>fillOval(,,,)</code></td><td>绘制一个椭圆</td></tr><tr><td><code>new Color(,,)</code></td><td>定义一个正常的颜色</td></tr></tbody></table><ol start="4"><li><p>监听者和被监听者</p><ul><li>实现过程：<ol><li>继承为一个监听器:<code>implements ActionListener</code></li><li>指定一个按钮:<code>.addActionLiastener(this)</code></li><li>定义被按动的行为:<code>actionOerformed()</code><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2></li></ol></li></ul></li><li><p>用指定的方法制作特定的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MidiEvent <span class="title">makeEvent</span><span class="params">(<span class="keyword">int</span> comd,<span class="keyword">int</span> chan,<span class="keyword">int</span> one,<span class="keyword">int</span> two,<span class="keyword">int</span> tick)</span></span>&#123;</span><br><span class="line">    MidiEvent a = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ShortMessage a = <span class="keyword">new</span> ShortMessage();</span><br><span class="line">        a.setMessage(comd,chan,one,two);</span><br><span class="line">        event = <span class="keyword">new</span> MidiEvent(a,tick);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用队列来完成保存记录</p></li></ol><h2 id="使用内部类"><a href="#使用内部类" class="headerlink" title="使用内部类"></a>使用内部类</h2><ol><li>外部类方面的相应状态的变更可以修改内部类的属性</li><li>使用内部类来完成动画的制作</li></ol><h2 id="layout部分"><a href="#layout部分" class="headerlink" title="layout部分"></a>layout部分</h2><ol><li>基本布局被分为五部分：north、west、center、east、north.<ol><li>添加布局：<code>frame.getContentPane().add(BorderLayout.CENTER,button)</code></li><li>注意整个布局</li></ol></li><li>layout manager:<ol><li>用于自动化完成控件的布局</li><li>BorderLayout:按照五部分分每个布局</li><li>FlowLayout:从左向右布局，期望非文字的控件</li><li>BoxLayout:类似FlowLayout布局，但是可以强制设置转换类型</li><li>具体使用见PPT</li><li>其他布局管理器：<ol><li>网格布局</li><li>网格组布局</li></ol></li><li>订制布局管理器</li></ol></li><li>各种布局须知：<ol><li>当Frame的大小改变Frame中的按钮的位置会随之改变的布局是：FlowLayout</li><li>将容器划分为固定的网格进行布局的布局管理器是：GridLayout</li><li>每个区域只能用那一个组件的布局管理器：<ol><li>BorderLayout</li><li>GridLayout</li><li>CardLayout</li></ol></li><li>组件大小随容器大小变化：<ol><li>BorderLayout</li><li>GridLayout</li></ol></li></ol></li></ol><h3 id="向图形上添加东西的方法"><a href="#向图形上添加东西的方法" class="headerlink" title="向图形上添加东西的方法"></a>向图形上添加东西的方法</h3><ol><li>在frame上放置widgt</li><li>在widgt上绘制2D图形<ol><li>创建自己的绘图组件：<ul><li>创建JPanel的子类</li><li>重写public void paintComponet(Graphics g){//TO-DO}</li><li><code>Image image = new ImageIcon(name).getImage();</code>：获得一个JPEG显示</li><li><code>g.drawImage(image,3,4,this)</code>：画出这个图，左边距离panel左侧3像素，上侧距离顶部4像素</li></ul></li><li>g参数所引用的对象实际上是个Graphics2D的实例<ol><li>但是想要引用Graphics2D对象，需要使用强制转化<ul><li><code>Graphics2D g2d = new (Graphics2D) g;</code></li></ul></li><li>setPaint():可以设置画笔</li></ol></li></ol></li><li>在widgt上绘制JPEG图</li></ol><h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><ol><li>嵌套布局</li><li>BorderLayout<ol><li>标准的五大布局</li><li>每个区域只能放置一个组件，很难保证控件保持原有的大小</li><li>中间区域只能有剩下部分的像素</li><li>不好进行直接像素设置大小</li></ol></li><li>FlowLayout<ol><li>面板默认的布局管理器</li><li>从左向右布局方式</li></ol></li><li>BoxLayout<ol><li>使用默认大小，按照加入方式进行添加</li><li>从上向下添加</li></ol></li><li>使用布局管理器来在Frame窗体中布置一个按钮，此按钮大小不手Frame框体大小变化影响<h2 id="简单界面组件"><a href="#简单界面组件" class="headerlink" title="简单界面组件"></a>简单界面组件</h2></li></ol><h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><ol><li>考Button:参见53页PPT Testfield.label<ol><li>是否继承</li><li>是够被监听</li><li>是否被布局</li><li>是够实现了actionperformed方法</li></ol></li><li>调用repaint方法由系统帮你调用，未必什么时候调用<ol><li>重绘过程是异步的</li><li>如果多次调用repaint()，那么只会调用最后一次</li></ol></li><li>实现被按动效果：如果被按动，那么重新绘制这个东西</li></ol><h3 id="Button的监听"><a href="#Button的监听" class="headerlink" title="Button的监听"></a>Button的监听</h3><ol><li>来源：java.awt.event</li><li>相应的监听事件：具体地请查API<ol><li>ActionListener:actionPerformed(ActionEvent ev)</li><li>ItemListener:itemStateChanged(ItemEvent ev)</li><li>KeyListener:<ul><li>keyPressed(KeyEvent ev)</li><li>keyReleased(KeyEvent ev)</li><li>keyTyped(KeyEvent ev)</li></ul></li></ol></li><li>取得ActionEvent：<ol><li>实现ActionListener这个接口<ul><li><code>implements ActionListener</code></li></ul></li><li>向按钮进行注册(告诉它你要监听事件)<ul><li><code>button.addActionListener(this)</code></li></ul></li><li>定义事件的处理方法</li></ol></li><li>多个监听：内部类来实现</li><li>所有的监听接口中定义的方法，访问权限都是public，返回值是void的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span>&#123;</span><br><span class="line">    button.setText(str);<span class="comment">//TO-DO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h3><ol><li><p>文本：JTextField</p><ol><li>允许编辑单行文本的文本组件</li><li>构造函数：<ul><li><code>JTextField field = new JTextField(20);</code></li><li><code>JTextField field = new JTextField(&quot;Your name&quot;)</code></li><li><code>JTextField field = new JTexField(String text, int columns)</code>构造使用要显示的指定文本初始化的新文本字段，宽度足够容纳指定列数。</li></ul></li><li>使用的方法：<ol><li><code>.getText()</code>：获得文本</li><li><code>.setText(str)</code>：设置文本<ul><li>如果是””，那么就是清空</li></ul></li><li><code>.addActionListener(this)</code>：添加监视器</li><li><code>.selectAll()</code>：选择全部文本</li><li><code>.requestFocus()</code>：将GUI焦点拉回文本段落来使得用户完成输入</li></ol></li></ol></li><li><p>文本域：JTextArea</p><ol><li>构造函数：<code>JTextArea text = new JTextArea(10,20)//行高和字宽</code></li><li>其他方法：<ol><li><code>.setText(str)</code></li><li><code>.append(str)</code></li><li><code>.selectAll()</code></li><li><code>.requestFocus()</code></li><li>设置垂直的滚动条：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JScrollPane scroller = <span class="keyword">new</span> JScrollPane(text);</span><br><span class="line">text.setLineWrap(<span class="keyword">true</span>);<span class="comment">//开启自动换行</span></span><br><span class="line">scroller.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);</span><br><span class="line">scroller.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);<span class="comment">//设置了垂直滚动条</span></span><br><span class="line">panel.add(scroller);</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>标签和标签组件:JLable</p></li><li><p>密码域</p></li><li><p>滚动窗格</p></li></ol><h3 id="选择组件"><a href="#选择组件" class="headerlink" title="选择组件"></a>选择组件</h3><ol><li>复选框</li><li>单选按钮</li><li>边框</li><li>组合框</li><li>滑块</li><li>JCheckBox：<ol><li>构造方法<ul><li><code>JCheckBox check = new JCheckBox(str)</code></li></ul></li><li>其他方法：<ul><li>添加监听Item的事件<ul><li><code>check.addItemListener(this)</code></li></ul></li><li>处理事件(判别是否被选中)<ul><li><code>.isSelected()</code></li><li>实现<code>public void itemStateChanged(ItemEvent ev){}</code></li></ul></li><li>用程序要设置选择或者不选择:<ul><li><code>check.setSelected(true);</code></li><li><code>check.setSelected(false);</code></li></ul></li></ul></li></ol></li></ol><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>JList</p><ol><li><p>构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//任意类型的数组即可</span></span><br><span class="line">list = <span class="keyword">new</span> JList(listEntries);</span><br></pre></td></tr></table></figure></li><li><p>具体使用：</p><ol><li>显示垂直滚动条：同JCheckBox</li><li>设置显示行数：<code>list.setVisibleRowCount(number)</code></li><li>限制单选:<code>.setSelectionMode(ListSelectionModel.SINGLE_SELECTION)</code></li><li>对选择事件做注册：<code>.addListSelectedListener(this)</code></li><li>处理选择事件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueChanged</span><span class="params">(ListSelectedEvent lse)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lse.getValueIsAdjusting())&#123;</span><br><span class="line">        String selection = (String) list.getSelectedValue();</span><br><span class="line">        System.out.println(selection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><h1 id="MVC-Design-Pattern"><a href="#MVC-Design-Pattern" class="headerlink" title="MVC Design Pattern"></a>MVC Design Pattern</h1><ol><li>MVC之间的交互</li><li>MVC模式<ol><li>模型：存储内容</li><li>视图：显示内容</li><li>控制器：处理用户输入</li></ol></li><li>controller模式:不同被点击形式等</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li>容器和组件是Composite模式</li><li>带滚动条的面板是Decorator模式</li><li>布局管理器是Strategy模式</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 虚拟机</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81/"/>
    <id>http://yoursite.com/2019/10/07/java/java_虚拟机和字节码/</id>
    <published>2019-10-07T05:52:05.664Z</published>
    <updated>2019-10-07T07:55:35.081Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><h1 id="内存和虚拟机"><a href="#内存和虚拟机" class="headerlink" title="内存和虚拟机"></a>内存和虚拟机</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ol><li>逻辑内存地址空间(Linux操作系统空间)<ol><li>内核空间</li><li>堆：从高向低分配</li><li>栈：局部变量:从低向高分配<blockquote><p>ebp：Main函数的栈针底部<br>esp:栈针顶部  </p></blockquote></li><li>代码段</li></ol></li><li><a href="file:///D:/南京大学/大一第二学期/软件工程与计算1-2019/课件/08%20-%20结构化编程%20III%20-%20方法.pdf" target="_blank" rel="noopener">JVM 51页</a>  <ol><li>方法区</li><li>引用类型变量对java对象访问的实现<ul><li>访问数据<ul><li>实例数据值（对象中各个实例字段的数据）</li><li>对象类型数据</li></ul></li><li>访问方式<ul><li>句柄方式访问：像是key一样</li><li>直接指针访问</li></ul></li></ul></li></ol></li></ol><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><ol><li>是机器的软件实现，可以像物理机一样执行程序</li><li>JVM的特性：<ol><li>基于栈的虚拟机：<ul><li>JVM基于栈进行运行</li></ul></li><li>标识符引用：<ul><li>所有类型(类和接口)除了基本类型（又称原始类型）都是通过表示符引用的，而不是显示的基于内存地址的引用</li></ul></li><li>垃圾收集：<ul><li>一个类的实例是由用户代码显式创建的并通过垃圾收集自动销毁</li></ul></li><li>通过清除的定义基本数据类型保证平台的独立<ul><li>JVM清除地定义了原始数据类型以维持兼容性和保证跨平台的能力。</li></ul></li><li>网络字节顺序<ul><li>JVM使用网络字节序，它是一种网络传输的顺序，网络字节序是big endian的<h1 id="java的编译和运行"><a href="#java的编译和运行" class="headerlink" title="java的编译和运行"></a>java的编译和运行</h1></li></ul></li></ol></li></ol><h2 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h2><ol><li>静态绑定</li><li>多分派</li><li>overloading</li><li>编译：将整个程序源代码翻译成另一种代码，然后等待被执行，发生在运行之前，产物是另一份代码</li></ol><h2 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h2><ol><li>动态绑定</li><li>单分派</li><li>overriding</li><li>强制类型转换在改阶段进行-&gt;会带来异常</li></ol><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>将程序源代码一行行的读懂，然后执行，发生在运行时，产物是运行结果。</p><h1 id="JVM和字节码"><a href="#JVM和字节码" class="headerlink" title="JVM和字节码"></a>JVM和字节码</h1><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>java对象在JVM中的存储：</p><ol><li>对象头：8b</li><li>java原始类型数据：</li><li>引用：4b</li><li>填充符</li></ol><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ol><li>java代码最后被编译成了字节码,字节码在虚拟机中被执行</li><li>字节码的语言无关性(不同语言被相应编译器编译后运行)</li><li><code>.class</code>文件就是字节码</li><li>查看字节码<ol><li><code>javac test.java</code></li><li><code>javap -verbose test</code>//打开参考区域</li></ol></li><li>constant pool:常量池</li></ol><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><ul><li>一组以8位字节为基础单位的二进制流</li><li>魔数(magic)文件开头</li><li>版本号(副版本号+朱版本号)</li><li>常量池计数器</li><li>常量池数据区：(单独写出来的部分)<ul><li>字面量</li><li>符号引用</li></ul></li><li>访问标志</li><li>类索引:<ol><li>有两个字节组成</li><li>两个字节中存储的值是某个变量池中的变量池常量池项CONSTANT_Class_info的索引</li><li>这个索引会进一步指向常量池项CANSTANT_Utf8_info，这项表示此类的完全先定名字符串</li></ol></li><li>父类索引(依据常量池)</li><li>接口计数器</li><li>接口信息数据区</li><li>字段计数器</li><li>字段信息数据区</li><li>方法计数器</li><li>方法信息数据区</li><li>属性计数器</li><li>属性信息数据区(代码的实现会被作为一个属性值)</li></ul><h3 id="参考图像"><a href="#参考图像" class="headerlink" title="参考图像"></a>参考图像</h3><ol><li>字节码图片(第一章)<ul><li>4：主版本号5：次版本号</li><li>6、7：长度</li></ul></li><li>第二张图片：<ul><li>class 名字叫2，看2，可知包+名称</li><li>0x14 = 20字节表示类的名字</li><li>01代表utf8下一个</li></ul></li></ol><h2 id="整体字节码：-按照顺序"><a href="#整体字节码：-按照顺序" class="headerlink" title="整体字节码：(按照顺序)"></a>整体字节码：(按照顺序)</h2><ol><li><p>首先是访问标志(访问这个类？)</p></li><li><p>然后是类索引(其中的值指向常量池中的值)</p><blockquote><p>如果常量池中保存的值依旧是索引，则继续指向常量池中的其他值</p></blockquote></li><li><p>之后是父类索引：通过查父类索引获得这个类是继承自哪个父类</p></li><li><p>父类索引后就是接口索引集合(接口计数器+接口信息数据区)</p><ol><li><p>接口计数器：用来获得接口有多少个</p></li><li><p>接口索引集合：用于保存在常量池中的索引集合</p></li><li><p>field_info结构体(JVM定义的)</p><ol><li><p>字段表示：作用域+静态or非静态+可变性+并发可见性+是否可序列化+数据类型+字段名称+其他属性</p></li><li><p>结构体实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field_info&#123;</span><br><span class="line">    u2 access_flags;<span class="comment">//前五项</span></span><br><span class="line">    u2 name_index;<span class="comment">//字段名称</span></span><br><span class="line">    u2 descriptor_index;<span class="comment">//数据类型</span></span><br><span class="line">    u2 attribute_count;<span class="comment">//其他属性</span></span><br><span class="line">    attribute_info attributes;<span class="comment">//其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存储格式：访问标志+名称索引+描述索引+属性计数器+many constantValues</p></li><li><p>3中的ConstantValue格式如下：属性名称索引(字符串的值为”ConstantVaule”)+属性长度(对应后面的常量值索引的字节长度，固定为2)+常量值索引(其中的值是赋给field字段的值)</p></li><li><p>图片参见ppt</p></li></ol></li></ol></li><li><p>方法表集合：</p><ol><li><p>方法计数器</p></li><li><p>方法信息数据区</p></li><li><p>方法表示：作用域+静态or非静态+可变性+是否同步+是否本地方法+是否抽象+方法描述+方法名称+方法内机器指令、异常信息、是否声明为deprecated</p></li><li><p>method_info例子：属性表集合</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info&#123;</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 name_index;</span><br><span class="line">    u2 descriptor_index;</span><br><span class="line">    u2 attribute_count;</span><br><span class="line">    attribute_info attributes；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存储形式：访问标志+名称索引+描述索引+属性计数器+many Attribute_info</p></li><li><p>5中的constantValue的格式：属性名称索引(字符串在常量池项中表示为”ConstantValue”)+属性长度(一般固定为2)+常量值索引(表示要复制给field字段的值)</p><ol><li>属性名称索引：<ol><li>占有两个字节，其中的值指向常量池中的某一项，该项表示的字符串表这个attribute——info是什么属性的属性表。<ul><li>Code:表示这个属性表记录的是机器码<ol><li>格式：机器指令+异常处理跳转信息+java源码行号和机器源码对应关系+局部变量表描述信息</li><li>具体参见ppt<ul><li>Exception：表示这个属性表记录的是异常信息</li></ul></li></ol></li><li>Deprecated：表示这个属性表记录的是被@Deprecated修饰的</li><li>Synthetic：表示此属性表被编译器自动生成</li></ul></li><li>对于不同类型的属性表，他们的<strong>属性长度和组织形式</strong>是不同的<ol><li>属性长度：如果值为n,则之后的n个字节是用来表示属性信息</li><li>属性值：由若干个字节构成，字节的个数由属性长度中的值决定</li></ol></li></ol></li></ol></li><li><p>文件实例：参见PPT中</p><ol><li>棕色字段：编译器自动生成的构造函数<code>&lt;init&gt;</code></li><li><code>()V</code>表示无返回值的void</li><li>对于Code类型属性表，其Attribute_info的格式是：属性名称索引+属性长度+栈的最大深度+局部变量表最大值+机器指令数目+机器指令+异常表+属性表集合</li><li>仔细参考40页</li></ol></li></ol></li><li><p>常量池中的信息大多按照字符串形式保存，按照之前规定的编码进行翻译</p></li></ol><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><ol><li><p>组成</p><ol><li>PC计数器：存了下一条指令</li><li>JVM栈：其中元素叫栈帧，存储局部变量表、操作栈、动态链接、方法出口等，栈的生命周期和线程相同</li><li>Heap(堆)：被所有线程共享，在虚拟机启动时创建，功能是存放所有对象实例，同样还是垃圾回收器管理的主要区域。</li><li>Method Area：方法区：被所有线程共享，用于存储已经被虚拟机加载的类信息、常量、静态变量，即使编译器编译出来的代码等数据</li><li>运行时常量池<ol><li>存放编译器生成的：<ol><li>各种字面量</li><li>符号引用</li></ol></li></ol></li><li>Native Methods Stacks(本地方法栈)：线程所私有，功能类似于JVM</li></ol></li><li><p>具体图像参考PPT</p></li><li><p>虚拟机栈是什么？有什么？</p><ol><li>是一个后入先出的栈</li><li>每一个线程创建时，都会同时为这个线程创建一个私有的虚拟机栈</li><li>调用方法时，JVM会相应地创建一个栈帧进入虚拟机(存储数据和储存部分过程中的数据结构)，同时也可以处理动态链接、方法返回值和异常分派</li><li>线程对方法的调用就对应一个栈帧的入栈和出的过程，当前活动栈帧是虚拟机的栈顶元素</li></ol></li><li><p>栈帧是什么？有什么？见PPT</p></li><li><p>方法区是什么？有什么？见PPT</p></li><li><p>String.intern():局部字符串池</p><ol><li>在串池中添加一个字符串</li><li>栈帧中的局部变量表中的槽位是可以重用的<blockquote><p>详见PPT中的代码块垃圾回收，重复使用槽位</p></blockquote></li></ol></li></ol><h2 id="字节码指令集"><a href="#字节码指令集" class="headerlink" title="字节码指令集"></a>字节码指令集</h2><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><ul><li>存储指令</li><li>算术与逻辑运算指令</li><li>类型转换指令</li><li>对象创建和操作指令</li><li>堆栈操作指令</li><li>控制转移指令</li><li>方法调用与返回指令</li></ul><h3 id="前后缀"><a href="#前后缀" class="headerlink" title="前后缀"></a>前后缀</h3><table><thead><tr><th>前后缀</th><th>操作数类型</th></tr></thead><tbody><tr><td>i</td><td>整数</td></tr><tr><td>l</td><td>长整数</td></tr><tr><td>s</td><td>短整数</td></tr><tr><td>b</td><td>字节</td></tr><tr><td>c</td><td>字符</td></tr><tr><td>f</td><td>单精度浮点数</td></tr><tr><td>d</td><td>双精度浮点数</td></tr><tr><td>z</td><td>布尔值</td></tr><tr><td>a</td><td>引用</td></tr></tbody></table><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><ol><li>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传输<ol><li>将一个局部变量加载到操作数栈的指令</li><li>将一个数值从操作数栈掉存储到局部变量表的指令</li><li>将常量加载到操作数栈的指令</li><li>局部变量表的访问索引指令</li></ol></li><li>一部分以尖括号结尾的指令代表了一组指令</li></ol><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><ol><li>算术指令用于对两个操作数栈上的值进行操作，并把结果重新存回操作帧顶。</li><li>处理除法是若除数为0，则虚拟机会抛出异常</li><li>在处理浮点数时，使用最接近数舍入模式<ul><li>所有数会被舍入到适当精度</li><li>如果两种可表示的形式与该值一样，会优先选择最低有效位为零的</li></ul></li><li>浮点数想整数进行转换，使用IEEE754标准下的像零舍入，截断数字</li></ol><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><ol><li>类型转换指令将两种java虚拟机是数值类型相互转换，常用于用户操作时的显式类型转换操作。</li><li>JVM直接仅支持宽化类型转换(小范围到大范围类型转换)<ol><li>int =&gt; long,double,float</li><li>long =&gt; float,double</li><li>float =&gt; double</li></ol></li><li>java虚拟机处理窄化类型：<ol><li>显式使用转换指令来完成</li><li>将int和long窄化成T时，舍弃T以外的全部字节</li><li>将浮点值转化成int或者long时:<ol><li>NaN =&gt; 0</li><li>使用IEEE754向零舍入，获得整数</li><li>否则，根据正负转化成为相应的最大值</li></ol></li></ol></li></ol><h3 id="对象创建于访问命令"><a href="#对象创建于访问命令" class="headerlink" title="对象创建于访问命令"></a>对象创建于访问命令</h3><ol><li>对于类实例和数组的创建和操作的指令并不相同</li><li></li></ol><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><h2 id="字节码在虚拟机中的执行"><a href="#字节码在虚拟机中的执行" class="headerlink" title="字节码在虚拟机中的执行"></a>字节码在虚拟机中的执行</h2><h3 id="类的声明周期"><a href="#类的声明周期" class="headerlink" title="类的声明周期"></a>类的声明周期</h3><ol><li>加载</li><li>连接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>初始化</li><li>使用</li><li>卸载</li><li>详情见PPT</li></ol><h2 id="java指令和字节码"><a href="#java指令和字节码" class="headerlink" title="java指令和字节码"></a>java指令和字节码</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol><li>局部变量:<br><code>int i = 69;</code>=&gt;<br><code>0:bipush 69 =&gt; 2:istore_0(将这个值存储到0号槽中)</code></li><li>成员变量:向成员变量中赋值，需要知道对象、类型、名称等<br><code>public int i = 100;</code>=&gt;  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1:aload_0</span><br><span class="line">2:bipush 100(添加100)</span><br><span class="line">4:putfield #2(存储到2中去)</span><br></pre></td></tr></table></figure></li></ol><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><ol><li>if-else:注释：<br><code>if_icmple 7</code>:如果20&lt;=10，调向第七条指令</li><li>Switch</li><li>String Switch</li></ol><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ol><li>while</li><li>do while</li></ol><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ol><li>字节码中#后面的是标签</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 异常</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/10/07/java/java_异常/</id>
    <published>2019-10-07T05:52:05.664Z</published>
    <updated>2019-10-07T07:55:39.156Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>java学习笔记之异常</strong></p><ol><li><p>使用<code>try{}catch{}</code>来捕捉异常</p><ol><li>try告诉系统在哪一部分的代码可能有问题</li><li>catch表示如果有异常的话如何处理</li></ol></li><li><p>在程序运行过程中出现的不能正常执行的情况称为异常</p></li><li><p>异常：在程序运行过程中出现的不能正常执行的情况</p><h1 id="异常的产生和接收"><a href="#异常的产生和接收" class="headerlink" title="异常的产生和接收"></a>异常的产生和接收</h1></li><li><p>在一个方法中抛出一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeRisk</span><span class="params">()</span> <span class="keyword">throws</span> BadException</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BadExcception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个地方接收这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crossFingers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(BadException ex)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以抛出多个异常和接收多个异常</p></li><li><p>多用于处理运行运行时错误</p></li><li><p>可以在最后添加<code>finally{}</code>:内部的操作无论如何都会被执行</p></li></ol><h1 id="多重异常"><a href="#多重异常" class="headerlink" title="多重异常"></a>多重异常</h1><ol><li>异常是一种多态，是对于Exception类的继承</li><li>多个异常累加的时候，我们从小到大放置</li><li>程序按照文本顺序来读取</li></ol><h1 id="抛出异常到外部"><a href="#抛出异常到外部" class="headerlink" title="抛出异常到外部"></a>抛出异常到外部</h1><ol><li>如果一个方法内部并不知道如何处理一个异常，将它抛出去,throws</li><li>程序内部抛出方法：throw</li><li>实例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">throws</span> ClothingException</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="异常的语法"><a href="#异常的语法" class="headerlink" title="异常的语法"></a>异常的语法</h1><ol><li>不能在try和catch之间有语句</li><li>可以没有finally<ul><li>finally子句中含有return语句：待查</li></ul></li><li>java7之后处理异常的新特性<ol><li>一个Catch语句可以捕获多个异常<ul><li><code>catch(Exception a|Exception b)</code></li></ul></li><li>更加精准的异常抛出<ul><li>精准抛出异常的例子：代码1-17:使用捕捉抛出再捕捉的方式</li></ul></li></ol></li><li>java7中的try-with-resources语句<ol><li>实现了自动关闭相关资源的能力，见代码清单1-19和1-20</li><li>一个可以打开多个文件：<code>try(a;b)</code></li></ol></li></ol><h1 id="使用异常机制的建议"><a href="#使用异常机制的建议" class="headerlink" title="使用异常机制的建议"></a>使用异常机制的建议</h1><ol><li>异常声明是API的一部分</li><li>异常处理不能代替简单的测试</li><li>不要过分地细化异常</li><li>利用异常层次结构<ul><li>不要只抛出RuntimeException，应该寻找更合适的子类或者创建自己的异常类</li></ul></li><li>不要压制异常</li><li>在检测错误时，苛刻比放任要好<ul><li>比如在错误的时候抛出EmptyStackException比抛出NullPointerException异常更好</li></ul></li><li>不要羞于传递异常<ul><li>早抛出，晚捕获</li></ul></li></ol><h1 id="创建自己的异常"><a href="#创建自己的异常" class="headerlink" title="创建自己的异常"></a>创建自己的异常</h1><ol><li>精心设计异常的层次结构</li><li>异常类中包含有足够的信息</li><li>异常与错误提示</li></ol><h1 id="异常的消失"><a href="#异常的消失" class="headerlink" title="异常的消失"></a>异常的消失</h1><ol><li>代码清单1-9:两种解决方法</li></ol><h1 id="一些异常实例"><a href="#一些异常实例" class="headerlink" title="一些异常实例"></a>一些异常实例</h1><ol><li>使用异常包装技术</li><li>使用国际化异常消息的异常类的基类</li><li>继承自支持国际化异常消息的异常类的子类</li></ol><h1 id="java虚拟机中的实现"><a href="#java虚拟机中的实现" class="headerlink" title="java虚拟机中的实现"></a>java虚拟机中的实现</h1><ol><li>athrow指令</li><li>红色部分是异常表，对应左侧行数</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 线程</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/07/java/java_线程/</id>
    <published>2019-10-07T05:52:05.664Z</published>
    <updated>2019-10-07T07:55:32.859Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>java学习笔记之线程</strong></p><ol><li>多线程是实现多任务的一种方式</li><li>线程是指进程中的一个执行流程，一个进程中可以运行多个线程。</li><li>进程是子一个内存中运行的应用程序，是独立的线程，它代表独立的执行代码。</li><li>Thread类：<ol><li>来源：java.lang.Thread类</li><li>方法：<ul><li>void join()</li><li>void start()</li><li>static void sleep()</li></ul></li></ol></li><li>线程注意<ol><li>一个线程被刚创建的时候，并没有立即开始运行</li><li>使用start()方法可以使一个线程成为可运行的，但是他不一定立即开始运行</li><li>一个线程可能因为不同的原因停止并进入就绪状态</li><li>当一个线程因为抢先机制而停止运行，它被放在可运行队列的前面</li></ol></li></ol><h1 id="java多线程编程"><a href="#java多线程编程" class="headerlink" title="java多线程编程"></a>java多线程编程</h1><ol><li>多线程保障了更小的资源开销</li><li>为了满足需要，充分利用CPU</li><li>程序在开始之初，只有main()线程，其他的所有线程都需要我们程序员自己创建线程，放到JVM中</li></ol><h2 id="多线程编程的问题以及解决"><a href="#多线程编程的问题以及解决" class="headerlink" title="多线程编程的问题以及解决"></a>多线程编程的问题以及解决</h2><ol><li>并发性问题<ul><li>对同一个对象进行操作时候的问题</li><li>可能会导致更新丢失</li></ul></li><li>解决方案：<ul><li>给线程加一个锁<ol><li>如果静态变量状态的保护呢？如果有静态的方法可以对静态变量的状态作更新，还能同步化吗？<ol><li>可以。静态的方法是运行在类而不是在每个实例上</li><li>在你对静态的方法做同步化方法做同步化时，Java会使用类本身的锁。也就是如果一个类中有两个方法被同步化过的静态方法，线程需要取得类的锁才能进行这些方法。</li></ol></li></ol></li><li>使用synchronized关键词<ol><li>按照不同的程序分析，来添加锁的部分</li></ol></li><li>同步化的代价：<ol><li>速度下降，会耗费性能来查询</li><li>有可能导致死锁现象：也就是说会互相持有钥匙</li><li>有可能造成死锁的问题：参考O’Reilly的“Java Thread”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doStuff();</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        a();</span><br><span class="line">        b();<span class="comment">//只对部分进行原子化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol><h1 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h1><h2 id="新建状态"><a href="#新建状态" class="headerlink" title="新建状态"></a>新建状态</h2><p>使用new关键字和Thread类或其子类建立一个线程对象后。这个线程对象就处于新建状态，它保持这个状态知道程序start()该线程。</p><ul><li><code>Thread t = new Thread();</code></li><li><code>t.start();</code></li></ul><h2 id="就绪状态"><a href="#就绪状态" class="headerlink" title="就绪状态"></a>就绪状态</h2><p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><h2 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h2><p>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><h2 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h2><p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： </p><ol><li>等待阻塞：运行状态中的线程执行wait()方法，使线程进入到等待阻塞状态</li><li>同步阻塞：线程获取synchronized同步锁失败，被占用</li><li>其他阻塞：调用线程的sleep()或join()发出了I/O请求，线程就进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或I/O处理完毕，线程重新进入就绪状态。</li><li>使用resume()来继续suspend的线程<h2 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h2>一个运行状态的线程完成任务或者其他终止发生时，该线程就切换到终止状态</li></ol><h1 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h1><ol><li>每个线程都有着优先级，便于操作系统确定线程的调度顺序</li><li>线程优先级的取值范围：1（Thread.MIN_PROIORITY)-10(Thread.MAX_PRIORITY)<ul><li>默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）</li></ul></li><li>优先级高的线程对程序更加重要，并且应该在低优先级的线程之前分配处理器资源，但是线程优先级不能保证线程执行的顺序，并且非常依赖平台。</li></ol><h1 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h1><p>三种创建线程的方法：</p><ol><li>通过实现Runnable接口<ol><li>通过创建一个类来实现(这个类继承)</li></ol></li><li>通过继承Thread类本身<ol><li>直接新建一个继承自Thread的类</li><li>创建一个实例</li><li>重写run()方法，代表新线程的入口点。</li><li>也需要调用start()方法才能执行。</li></ol></li><li>通过Callable和Future创建线程<ol><li>创建Callable接口的实现类，并实现call()方法，该call()方法作为线程执行体，并且有相应的返回值。</li><li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该对象的call()方法返回</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ol></li></ol><h1 id="如何启动新的线程"><a href="#如何启动新的线程" class="headerlink" title="如何启动新的线程"></a>如何启动新的线程</h1><ol><li>建立Runnable对象：<ul><li><code>Runnable threadJob = new MyRunnable();</code></li></ul></li><li>建立Thread对象(执行工人)并赋值Runnable(任务):<ul><li><code>Thread myThread = new Thread(threadJob);</code></li></ul></li><li>启动Thread:<ul><li><code>myThread.start()</code></li></ul></li><li>Runnable接口只有一个方法:public void run()</li></ol><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><ol><li>一个线程运行GUI</li><li>另一个线程接受相关的反映</li><li>一个主线程来接收连接，n个子线程来服务n个客户端</li><li>线程的调用时间和顺序是受虚拟机进行控制的</li></ol><h1 id="线程调度器"><a href="#线程调度器" class="headerlink" title="线程调度器"></a>线程调度器</h1><ol><li>线程调度器决定哪个线程从等待状况中被挑出来运行，以及何时哪个线程送回等待被执行的状态</li><li>你是无法控制调度，没有API可以调用调度器</li><li>不可以假设在一个机器上测试多线程程序，就假定每一个机器上都是相同的调用行为</li><li>现在的虚拟机很难让你的线程一路执行到底，原因是sleep，在睡眠的过程中一个线程一定不会被唤醒<ul><li>这个部分你要放在try…catch…块中来完成</li></ul></li><li>不同优先级的线程间是抢先式的，而同级线程间是轮转式的。</li></ol><h1 id="线程Thread类的方法"><a href="#线程Thread类的方法" class="headerlink" title="线程Thread类的方法"></a>线程Thread类的方法</h1><table><thead><tr><th>方法名</th><th>方法作用</th></tr></thead><tbody><tr><td>setName(String str)</td><td>设置线程的名字</td></tr><tr><td>getName()</td><td>获得线程的名字</td></tr><tr><td>currentThread()</td><td>获得当前的线程</td></tr></tbody></table><h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><ol><li>保证你的操作是安全的</li><li>可以用来修饰方法使得方法每次只能被单一的线程调用</li><li>可以用来修饰对象，对象的锁只能在有同步化方法上起作用<ul><li>当对象有一个或者多个同步化的方法时，线程只有取得对象的锁的钥匙的时候，才能进入同步化方法</li></ul></li></ol><h1 id="描述java创建线程"><a href="#描述java创建线程" class="headerlink" title="描述java创建线程"></a>描述java创建线程</h1><p>进程是程序的一次动态执行过程，它对应了从代码加载、执行到执行完毕的一个完整过程，这个过程也是进程本身从产生、发展到消亡的过程。作为执行蓝本的同一段程序，可以被多次加载到系统的不同内存区域分别执行，形成不同的进程。每个进程都有独立的代码和数据空间(进程上下文)，进程切换的开销大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java学习笔记 之 序列化</title>
    <link href="http://yoursite.com/2019/10/07/java/java_%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2019/10/07/java/java_序列化/</id>
    <published>2019-10-07T05:52:05.664Z</published>
    <updated>2019-10-07T07:55:37.318Z</updated>
    
    <content type="html"><![CDATA[<p>点击查看详情</p><a id="more"></a><p><strong>序列化以及文件输入输出</strong></p><ol><li>对象有状态和行为，行为存在于类中，而状态存在于个别的对象中，方便被非java程序读取</li></ol><h1 id="存储对象"><a href="#存储对象" class="headerlink" title="存储对象"></a>存储对象</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><ol><li>只有自己写的java程序会用到这些数据</li><li>更加的安全</li><li>如果让类可以序列化，实现Serializable接口</li><li>可以父类不被序列化，但是子类实现序列化</li><li>序列化过程中会辨别两个对象是否相同，这种情况下只有一个对象会被保存，剩下的会被指向这个引用</li></ol><h3 id="序列化对象写入文件"><a href="#序列化对象写入文件" class="headerlink" title="序列化对象写入文件"></a>序列化对象写入文件</h3><ol><li>创建文件输出流<ul><li><code>FileOutputStream fileStream = new FileOutputStream(&quot;MyGame.ser&quot;)</code></li><li>文件不存在会直接创建出来</li></ul></li><li>创建对象输出流<ul><li><code>ObjectOutputStream os = new ObjectOutputStream(fileStream);</code></li></ul></li><li>写入对象:<ul><li><code>os.writeObject(character);</code></li></ul></li><li>关闭流：<ul><li><code>os.close();</code></li></ul></li><li>整个过程就是对象被碾平，然后当做字节写入文件</li></ol><h3 id="会被序列化的东西"><a href="#会被序列化的东西" class="headerlink" title="会被序列化的东西"></a>会被序列化的东西</h3><ol><li>所有的实例变量</li><li>所有被引用的对象</li><li>保证里面的都可以被序列化</li></ol><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><ol><li>用于某个实例变量不应该或不能被序列化</li></ol><h2 id="解序列化"><a href="#解序列化" class="headerlink" title="解序列化"></a>解序列化</h2><ol><li>静态变量还原的时候，会维持原来的样子，而不是存储的样子<ul><li>也就是说静态变量是归属于类所有的，不会被序列化，在解序列化的时候维持类声明时的状态<h3 id="解序列化过程"><a href="#解序列化过程" class="headerlink" title="解序列化过程"></a>解序列化过程</h3></li></ul></li><li>创建文件读入流<ul><li><code>FileInputStream filestream = new FileInputStream(&quot;name&quot;);</code></li></ul></li><li>创建对象读入流<ul><li><code>ObjectInputStream os = new ObjectInputStream(fileStream);</code></li></ul></li><li>读入对象<ul><li><code>Object a = os.readObject();</code></li></ul></li><li>转换对象类型<ul><li><code>Game g = (Game) a;</code></li></ul></li><li>关闭对象读入流<ul><li><code>os.close();</code></li></ul></li></ol><h3 id="详解解序列化过程"><a href="#详解解序列化过程" class="headerlink" title="详解解序列化过程"></a>详解解序列化过程</h3><ol><li>从流中读出对象</li><li>java虚拟机通过存储信息判断class类型</li><li>java虚拟机尝试寻找和加载对象的类。如果找不到会抛出异常</li><li>新的对象会被放置到堆上，但是构造函数不会执行</li><li>如果对象在继承书上有一个不可以序列化的祖先类，那么该不可序列化类以及在它之上的类的构造函数会被执行</li><li>对象的实例变量全部恢复，transient的变量会被赋值为null的对象引用或者primitive的主类型默认值</li></ol><h2 id="写纯文本文件"><a href="#写纯文本文件" class="headerlink" title="写纯文本文件"></a>写纯文本文件</h2><ol><li>会被其他程序使用到相应的数据<ul><li>比如写成用Tab字符来分隔的档案，方便数据库识别</li></ul></li><li>使用FileWriter来代替FileOutputStream<ol><li>使用try…catch</li><li>FileWriter writer = new FileWriter(src)</li><li>最后记着关闭.close()</li></ol></li><li>使用BufferedWriter写纯文本<ol><li>强制写入：<code>.flush()</code></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;点击查看详情&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
